{
  "swagger" : "2.0",
  "info" : {
    "description" : "Welcome to **Woleet API reference documentation**.<br>\nIt is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation.\n",
    "version" : "1.6.2",
    "title" : "Woleet API",
    "termsOfService" : "https://doc.woleet.io/docs/terms-of-service",
    "contact" : {
      "url" : "https://www.woleet.io/",
      "email" : "contact@woleet.com"
    }
  },
  "host" : "api.woleet.io",
  "basePath" : "/v1",
  "tags" : [ {
    "name" : "anchor",
    "description" : "Create and manage anchors."
  }, {
    "name" : "receipt",
    "description" : "Get and verify proof receipts."
  }, {
    "name" : "signatureRequest",
    "description" : "Create and manage signature requests."
  }, {
    "name" : "token",
    "description" : "Create and revoke JWT tokens."
  }, {
    "name" : "user",
    "description" : "Manage user information."
  }, {
    "name" : "domain",
    "description" : "Manage domain users."
  } ],
  "schemes" : [ "https" ],
  "consumes" : [ "application/json" ],
  "produces" : [ "application/json" ],
  "security" : [ {
    "BasicAuth" : [ ]
  }, {
    "JWTAuth" : [ ]
  } ],
  "paths" : {
    "/anchor" : {
      "post" : {
        "tags" : [ "anchor" ],
        "summary" : "Create a new anchor.",
        "description" : "Use this operation to create a new anchor of one of these two types:<br>\n\n- a data anchor (generating a proof of existence receipt) allows to prove the existence of some data at some point in time.<br>\n- a signature anchor (generating a proof of signature receipt) allows to prove the existence of the signature of some data at some point in time, the validity of the signature and the signee's identity.<br>\n\nThe properties `id`, `created`, `lastModified`, `status`, `timestamp` and `confirmations` are read-only and so must not be provided: they are managed by the platform and added to the returned anchor.<br>\nFor data anchors, only the properties `name` and `hash` are required: the `hash` property must be the SHA256 hash of the data to anchor, and must be computed caller side. This allows not to leak the original data.<br>\nFor signature anchors, only the properties `name`, `signedHash`, `signature` and `pubKey` are required (though the `identityURL` property is highly recommended): the `signedHash` property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).<br>\nBe sure to have at least 1 anchoring credit on your account. The `signature` property must contain a valid signature of the `data` property using the private key paired with the `pubKey` public key.\n",
        "operationId" : "createAnchor",
        "parameters" : [ {
          "in" : "body",
          "name" : "anchor",
          "description" : "Anchor object to create.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/anchor"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The created anchor (for signature anchors, the `hash` property is automatically set to the SHA256 of the signature, which is what is actually anchored into the blockchain).",
            "schema" : {
              "$ref" : "#/definitions/anchor"
            }
          },
          "400" : {
            "description" : "Invalid anchor object. More details are returned in the response body as a JSON object."
          },
          "402" : {
            "description" : "Insufficient credits."
          }
        }
      }
    },
    "/anchor/{anchorId}" : {
      "get" : {
        "tags" : [ "anchor" ],
        "summary" : "Get an anchor by its identifier.",
        "description" : "Use this operation to retrieve an anchor by its identifier.",
        "operationId" : "getAnchor",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor to retrieve.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The anchor.",
            "schema" : {
              "$ref" : "#/definitions/anchor"
            }
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        }
      },
      "put" : {
        "tags" : [ "anchor" ],
        "summary" : "Update an anchor.",
        "description" : "Use this operation to update an anchor.<br>\nOnly the properties `name`, `public`, `tags`, `metadata` and `callbackURL` can be modified.\n",
        "operationId" : "updateAnchor",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of anchor to update.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "anchor",
          "description" : "Anchor object to update.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/anchor"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The updated anchor.",
            "schema" : {
              "$ref" : "#/definitions/anchor"
            }
          },
          "400" : {
            "description" : "Invalid anchor object. More details are returned in the response body as a JSON object."
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        }
      },
      "delete" : {
        "tags" : [ "anchor" ],
        "summary" : "Delete an anchor.",
        "description" : "Use this operation to delete an anchor.<br>\n**WARNING: You should never delete an anchor, otherwise you will no longer be able to download its proof receipt.<br>\nUse this for test purpose only.**\n",
        "operationId" : "deleteAnchor",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor to delete.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The anchor is deleted."
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        }
      }
    },
    "/anchorids" : {
      "get" : {
        "tags" : [ "anchor" ],
        "summary" : "Search for public anchors' identifiers.",
        "description" : "Use this operation to retrieve the identifiers of all public anchors having a given `hash` and/or `signedHash` property.<br>\nOnly public anchors' identifiers are returned.<br>\nThis is a publicly accessible endpoint: authentication is not required to retrieve public anchors' identifiers.<br>\nPaging is supported.\n",
        "operationId" : "searchAnchorIds",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of anchors per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "hash",
          "in" : "query",
          "description" : "`hash` to search for: all public anchors whose `hash` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "signedHash",
          "in" : "query",
          "description" : "`signedHash` to search for: all public anchors whose `signedHash` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "An array (possibly empty) of the identifiers of all public anchors matching all search criteria, plus additional paging information.",
            "schema" : {
              "$ref" : "#/definitions/anchorIds"
            }
          }
        },
        "security" : [ ]
      }
    },
    "/anchors" : {
      "get" : {
        "tags" : [ "anchor" ],
        "summary" : "Search for anchors.",
        "description" : "Use this operation to retrieve all anchors having a given `name`, `hash`, `signedHash` and/or `tags` property.<br>\nOnly anchors belonging to the authenticated user are returned.<br>\nPaging and sorting is supported.\n",
        "operationId" : "searchAnchors",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of anchors per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "direction",
          "in" : "query",
          "description" : "Sorting direction: ASC for ascending DESC for descending.\n",
          "required" : false,
          "type" : "string",
          "default" : "ASC",
          "enum" : [ "ASC", "DESC" ]
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sorting property: possible values are limited to `id`, `created`, `hash` and `signedHash`.\n",
          "required" : false,
          "type" : "string",
          "default" : "created",
          "enum" : [ "id", "created", "hash", "signedHash" ]
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "`name` to search for: all anchors whose `name` property contains this sub-string are returned.<br>\n**WARNING: Searching by name can timeout on a large anchor set.**\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "hash",
          "in" : "query",
          "description" : "`hash` to search for: all anchors whose `hash` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "signedHash",
          "in" : "query",
          "description" : "`signedHash` to search for: all anchors whose `signedHash` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "tags",
          "in" : "query",
          "description" : "`tags` to search for: all anchors having all of these tags sets are returned.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An array (possibly empty) of all anchors matching all search criteria, plus additional paging and sorting information.",
            "schema" : {
              "$ref" : "#/definitions/anchors"
            }
          },
          "504" : {
            "description" : "Can be triggered when searching by name if the request takes too long to process."
          }
        }
      }
    },
    "/receipt/{anchorId}" : {
      "get" : {
        "tags" : [ "receipt" ],
        "summary" : "Get the proof receipt of an anchor (Chainpoint proof format).",
        "description" : "Use this operation to retrieve the Chainpoint proof receipt associated to a given anchor.\nThis is a publicly accessible endpoint: authentication is not required to retrieve a proof receipt (but the anchor identifier need to be known).\n",
        "operationId" : "getReceipt",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor for which to build the proof receipt.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The proof receipt (conform to the Chainpoint format).",
            "schema" : {
              "$ref" : "#/definitions/receipt"
            }
          },
          "202" : {
            "description" : "The proof receipt is not ready for this anchor."
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        },
        "security" : [ ]
      }
    },
    "/receipt/{anchorId}/ots" : {
      "get" : {
        "tags" : [ "receipt" ],
        "summary" : "Get the proof receipt of an anchor (OpenTimestamps proof format).",
        "description" : "Use this operation to retrieve the OpenTimestamps proof receipt associated to a given anchor.\nThis is a publicly accessible endpoint: authentication is not required to retrieve a proof receipt (but the anchor identifier need to be known).\n",
        "operationId" : "getOTSReceipt",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor for which to build the proof receipt.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The proof receipt (conform to the OpenTimestamps format).",
            "schema" : {
              "$ref" : "#/definitions/otsReceipt"
            }
          },
          "202" : {
            "description" : "The proof receipt is not ready for this anchor."
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        },
        "security" : [ ]
      }
    },
    "/receipt/verify" : {
      "post" : {
        "tags" : [ "receipt" ],
        "summary" : "Verify a proof receipt.",
        "description" : "Use this operation to verify a Chainpoint proof receipt and get the timestamp of the proof.<br>\nFor proof of signature receipts including an identity URL, this operation also verify and returns information about the signee's identity.<br>\nThis is a publicly accessible endpoint: authentication is not required to verify a proof receipt.\n",
        "operationId" : "verifyReceipt",
        "parameters" : [ {
          "in" : "body",
          "name" : "receipt",
          "description" : "Chainpoint proof receipt to verify.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/receipt"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The proof receipt verification status.",
            "schema" : {
              "$ref" : "#/definitions/receiptVerificationStatus"
            }
          },
          "400" : {
            "description" : "Invalid proof receipt object. More details are returned in the response body as a JSON object."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest" : {
      "post" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Create a new signature request.",
        "description" : "Use this operation to create a new signature request.<br>\nThe properties `id`, `created` and `lastModified` are read-only and so must not be provided: they are managed by the platform and added to the returned request.<br>\nOnly the properties `name` and `hashToSign` are required: the `hashToSign` property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).<br>\nBe sure to have enough signature and anchoring credits on your account to fulfill the signature request (each registered signature will cost you 1 signature and 1 anchoring credit).<br>\n",
        "operationId" : "createSignatureRequest",
        "parameters" : [ {
          "in" : "body",
          "name" : "signatureRequest",
          "description" : "SignatureRequest object to create.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The created signature request.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequest"
            }
          },
          "400" : {
            "description" : "Invalid signature request object. More details are returned in the response body as a JSON object."
          }
        }
      }
    },
    "/signatureRequest/{requestId}/otp/{signeeId}" : {
      "get" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Generate and send a One Time Password to a signee of a signature request.",
        "description" : "Use this operation to generate and send a One Time Password by SMS to a signee of a signature request.<br>\n",
        "operationId" : "sendSignatureRequestOTP",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "signeeId",
          "in" : "path",
          "description" : "Secret identifier of the signee wanting to retrieve his One Time Password.<br>\n**This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**\n",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "signature",
          "description" : "Signature to register.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequestSign"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "One Time Password succesfully generated and sent by SMS to the signee."
          },
          "401" : {
            "description" : "Unauthorized. The signee is not an authorized signee (signee identifier not found)."
          },
          "403" : {
            "description" : "Forbidden. The signature request is suspended, the deadline has been reached, or the signee does not requires One Time Password."
          },
          "404" : {
            "description" : "Signature request or signee not found."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest/{requestId}/sign" : {
      "post" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Sign a signature request.",
        "description" : "Use this operation to register a signature in a signature request.<br>\nThe signature is automatically anchored (on behalf of the owner of the signature request).<br>\nThe signature anchor created is added to the list of signature anchors of the signature request.<br>\nThis is a publicly accessible endpoint: authentication is not required to register a signature.\n",
        "operationId" : "signSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "signature",
          "description" : "Signature to register.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequestSign"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Signature succesfully registered. The signature anchor created is returned.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequestSignResult"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "401" : {
            "description" : "Unauthorized. The signee is not an authorized signee (public key or signee identifier not found, or invalid One Time Password)."
          },
          "402" : {
            "description" : "Insufficient credits. The owner of the signature request runs out of signature or anchoring credit."
          },
          "403" : {
            "description" : "Forbidden. The signature request is suspended, the deadline has been reached, or the maximum number of signatures has been reached."
          },
          "404" : {
            "description" : "Signature request not found."
          },
          "409" : {
            "description" : "Conflict. The signee has already signed."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest/{requestId}" : {
      "get" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Get a signature request by its identifier.",
        "description" : "Use this operation to retrieve a signature request by its identifier.<br>\nWhen accessed with no authentication, only public attributes of the signature request are returned.\n",
        "operationId" : "getSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request to retrieve.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "signeeId",
          "in" : "query",
          "description" : "Secret identifier of the signee wanting to retrieve the signature request.<br>\nIf set, information related to this signee is returned in `authorizedSignees[0]`.<br>\n**This secret identifier is generated by the platform and only included in the email sent to the signee, allowing the platform to authenticate the signee.**\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The signature request.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequest"
            }
          },
          "404" : {
            "description" : "No signature request matching the given identifier."
          }
        }
      },
      "put" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Update a signature request.",
        "description" : "Use this operation to update a signature request.<br>\nOnly the properties `name`, `suspended`, `deadline`, `maxSignatures` and `authorizedSignees` can be modified.<br>\n",
        "operationId" : "updateSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of signature request to update.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "request",
          "description" : "SignatureRequest object to update.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The updated signature request.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequest"
            }
          },
          "400" : {
            "description" : "Invalid signature request object. More details are returned in the response body as a JSON object."
          },
          "404" : {
            "description" : "No signature request matching the given identifier."
          }
        }
      },
      "delete" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Delete a signature request.",
        "description" : "Use this operation to delete a signature request.<br>\n",
        "operationId" : "deleteSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request to delete.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The signature request is deleted."
          },
          "404" : {
            "description" : "No signature request matching the given identifier."
          }
        }
      }
    },
    "/signatureRequests" : {
      "get" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Search for signature requests.",
        "description" : "Use this operation to retrieve all signature requests having a given `name` and/or `hashToSign` property.<br>\nOnly requests belonging to the authenticated user are returned.<br>\nPaging and sorting is supported.\n",
        "operationId" : "searchSignatureRequests",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of anchors per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "direction",
          "in" : "query",
          "description" : "Sorting direction: ASC for ascending DESC for descending.\n",
          "required" : false,
          "type" : "string",
          "default" : "ASC",
          "enum" : [ "ASC", "DESC" ]
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sorting property: possible values are limited to `id`, `created` and `hashToSign`.\n",
          "required" : false,
          "type" : "string",
          "default" : "created",
          "enum" : [ "id", "created", "hashToSign" ]
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "`name` to search for: all signature requests whose `name` property contains this sub-string are returned.<br>\n**WARNING: Searching by name can timeout on a large signature request set.**\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "hashToSign",
          "in" : "query",
          "description" : "`hashToSign` to search for: all signature requests whose `hashToSign` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequests"
            }
          },
          "504" : {
            "description" : "Can be triggered when searching by name if the request takes too long to process."
          }
        }
      }
    },
    "/token" : {
      "get" : {
        "tags" : [ "token" ],
        "summary" : "Generate a JWT token.",
        "description" : "Use this operation to generate a new JWT token.<br>\nJWT tokens can be used to authenticate to the API, using the `Bearer` scheme of the `Authorization` header, like:<br>\n`Authorization: Bearer {JWT token}`\n",
        "operationId" : "generateToken",
        "parameters" : [ {
          "name" : "cdata",
          "in" : "query",
          "description" : "Client data to inject into the generated JWT token (64 characters max).<br>\nThis data is not processed by the platform, and can be easily retrieved from the token by BASE64 decoding its `payload`.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The JWT token.",
            "schema" : {
              "$ref" : "#/definitions/token"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        }
      },
      "delete" : {
        "tags" : [ "token" ],
        "summary" : "Revoke a JWT token.",
        "description" : "Use this operation to revoke a JWT token.<br>\nJWT tokens have no expiration date so are always valid: if you need to invalidate a token (eg. because you think it is compromised) you need to use this endpoint to inform the platform that this token must no longer be accepted.\n",
        "operationId" : "revokeToken",
        "parameters" : [ {
          "name" : "token",
          "in" : "query",
          "description" : "JWT token to revoke.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The JWT token is revoked."
          },
          "400" : {
            "description" : "Invalid JWT token object. More details are returned in the response body as a JSON object."
          }
        }
      }
    },
    "/user/credits" : {
      "get" : {
        "tags" : [ "user" ],
        "summary" : "Get user's credits.",
        "description" : "Use this operation to get the remaining signature and anchoring credits of the authenticated user.<br>\n",
        "operationId" : "getCredits",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The remaining signature and anchoring credits.",
            "schema" : {
              "$ref" : "#/definitions/credits"
            }
          }
        }
      }
    },
    "/user/tokens" : {
      "get" : {
        "tags" : [ "user" ],
        "summary" : "Get user's registered JWT tokens.",
        "description" : "Use this operation to list all JWT tokens registered for the authenticated user.\n",
        "operationId" : "getTokens",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The list of JWT tokens of the user, possibly empty.",
            "schema" : {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            }
          }
        }
      },
      "put" : {
        "tags" : [ "user" ],
        "summary" : "Update user's registered JWT tokens.",
        "description" : "Use this operation to update the list of JWT tokens registered for the authenticated user.\n",
        "operationId" : "putTokens",
        "parameters" : [ {
          "in" : "body",
          "name" : "tokens",
          "description" : "The list of JWT tokens to updated.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/tokens"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of JWT tokens was successfully updated."
          }
        }
      }
    },
    "/user/callbackSecret" : {
      "get" : {
        "tags" : [ "user" ],
        "summary" : "Get the currently used callback secret (null if not set).",
        "description" : "Use this operation to get the api callback secret.<br>\n",
        "operationId" : "getCallbackSecret",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The currently used callback secret.",
            "schema" : {
              "$ref" : "#/definitions/callbackSecret"
            }
          }
        }
      },
      "put" : {
        "tags" : [ "user" ],
        "summary" : "Generates a new callback secret.",
        "description" : "Use this operation to generate the api callback secret.<br>\n",
        "operationId" : "updateCallbackSecret",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The newly generated callback secret.",
            "schema" : {
              "$ref" : "#/definitions/callbackSecret"
            }
          }
        }
      }
    },
    "/domain/admin/user" : {
      "post" : {
        "tags" : [ "domain" ],
        "summary" : "Create a new domain user.",
        "description" : "Use this operation to create a new domain user.<br>\nThe properties `id`, `created`, `lastModified`, `info` and `status` are read-only and so must not be provided: they are managed by the platform and added to the returned anchor.\n",
        "operationId" : "createDomainUser",
        "parameters" : [ {
          "in" : "body",
          "name" : "user",
          "description" : "User object to create (password must be provided).",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/user"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The created user.",
            "schema" : {
              "$ref" : "#/definitions/user"
            }
          },
          "400" : {
            "description" : "Invalid user object. More details are returned in the response body as a JSON object."
          }
        }
      }
    },
    "/domain/admin/user/{userId}" : {
      "get" : {
        "tags" : [ "domain" ],
        "summary" : "Get a domain user by its identifier.",
        "description" : "Use this operation to retrieve a domain user by its identifier.",
        "operationId" : "getDomainUser",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "Identifier of the domain user to retrieve.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The user.",
            "schema" : {
              "$ref" : "#/definitions/user"
            }
          },
          "404" : {
            "description" : "No user matching the given identifier."
          }
        }
      },
      "put" : {
        "tags" : [ "domain" ],
        "summary" : "Update a domain user.",
        "description" : "Use this operation to update a domain user.",
        "operationId" : "updateDomainUser",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "Identifier of the domain user to update.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "user",
          "description" : "User object to update.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/user"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The updated user.",
            "schema" : {
              "$ref" : "#/definitions/user"
            }
          },
          "400" : {
            "description" : "Invalid user object. More details are returned in the response body as a JSON object."
          },
          "404" : {
            "description" : "No user matching the given identifier."
          }
        }
      },
      "delete" : {
        "tags" : [ "domain" ],
        "summary" : "Delete a domain user.",
        "description" : "Use this operation to delete a domain user.",
        "operationId" : "deleteDomainUser",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "Identifier of the domain user to delete.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The user is deleted."
          },
          "404" : {
            "description" : "No user matching the given identifier."
          }
        }
      }
    },
    "/domain/admin/users" : {
      "get" : {
        "tags" : [ "domain" ],
        "summary" : "Search for domain users.",
        "description" : "Use this operation to list all domain users or search for domain users given their email.<br>\nPaging and sorting is supported.\n",
        "operationId" : "searchDomainUsers",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of users per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "direction",
          "in" : "query",
          "description" : "Sorting direction: ASC for ascending DESC for descending.\n",
          "required" : false,
          "type" : "string",
          "default" : "ASC",
          "enum" : [ "ASC", "DESC" ]
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sorting property: possible values are `email`, `created`, `roles`, `info.firstName`, `info.lastName`, `status`.\n",
          "required" : false,
          "type" : "string",
          "default" : "created",
          "enum" : [ "email", "created", "roles", "info.firstName", "info.lastName", "status" ]
        }, {
          "name" : "email",
          "in" : "query",
          "description" : "email to search for: a sub-string of the email.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "An array of all users matching all search criteria, plus additional paging and sorting information.",
            "schema" : {
              "$ref" : "#/definitions/users"
            }
          }
        }
      }
    }
  },
  "securityDefinitions" : {
    "BasicAuth" : {
      "description" : "Basic authentication over `HTTPS`.<br>\nYou must provide `BASE64(\"{email}:{password}\")` in the `Basic` scheme of the `Authorization` header.\n",
      "type" : "basic"
    },
    "JWTAuth" : {
      "description" : "JWT authentication over `HTTPS`.<br>\nYou must provide a JWT token value in the `Bearer` scheme of the `Authorization` header.\n",
      "type" : "apiKey",
      "name" : "Authorization",
      "in" : "header"
    }
  },
  "definitions" : {
    "receipt" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "Chainpoint 2.x only. Type of Chainpoint 2.x receipt."
        },
        "targetHash" : {
          "type" : "string",
          "description" : "Chainpoint 2.x only. SHA256 hash of the proven data or signature."
        },
        "merkleRoot" : {
          "type" : "string",
          "description" : "Chainpoint 2.x only. Root of the Merkle tree."
        },
        "proof" : {
          "type" : "array",
          "description" : "Chainpoint 2.x only. Merkle proof: path from `targetHash` to `merkleRoot` in the Merkle tree.\n",
          "items" : {
            "$ref" : "#/definitions/receipt_proof_node"
          }
        },
        "anchors" : {
          "type" : "array",
          "description" : "Chainpoint 2.x only. List of sources where the root of the Merkle proof is anchored.",
          "items" : {
            "$ref" : "#/definitions/receipt_anchors_node"
          }
        },
        "signature" : {
          "$ref" : "#/definitions/receipt_signature"
        },
        "header" : {
          "$ref" : "#/definitions/receipt_header"
        },
        "target" : {
          "$ref" : "#/definitions/receipt_target"
        }
      },
      "description" : "A Chainpoint 1.x or 2.x proof receipt",
      "example" : {
        "targetHash" : "targetHash",
        "signature" : {
          "signedIssuerDomain" : "signedIssuerDomain",
          "signature" : "signature",
          "signedHash" : "signedHash",
          "identityURL" : "identityURL",
          "signedIdentity" : "signedIdentity",
          "pubKey" : "pubKey"
        },
        "header" : {
          "chainpoint_version" : "1.0",
          "merkle_root" : "merkle_root",
          "tx_id" : "tx_id",
          "hash_type" : "SHA-256",
          "timestamp" : 0
        },
        "merkleRoot" : "merkleRoot",
        "proof" : [ {
          "left" : "left",
          "right" : "right"
        }, {
          "left" : "left",
          "right" : "right"
        } ],
        "anchors" : [ {
          "sourceId" : "sourceId",
          "type" : "BTCOpReturn"
        }, {
          "sourceId" : "sourceId",
          "type" : "BTCOpReturn"
        } ],
        "type" : "type",
        "target" : {
          "target_hash" : "target_hash",
          "target_proof" : [ {
            "parent" : "parent",
            "left" : "left",
            "right" : "right"
          }, {
            "parent" : "parent",
            "left" : "left",
            "right" : "right"
          } ]
        }
      }
    },
    "receipt_proof_node" : {
      "type" : "object",
      "properties" : {
        "left" : {
          "type" : "string"
        },
        "right" : {
          "type" : "string"
        }
      },
      "example" : {
        "left" : "left",
        "right" : "right"
      }
    },
    "receipt_anchors_node" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "default" : "BTCOpReturn"
        },
        "sourceId" : {
          "type" : "string"
        }
      },
      "example" : {
        "sourceId" : "sourceId",
        "type" : "BTCOpReturn"
      }
    },
    "receipt_signature" : {
      "type" : "object",
      "properties" : {
        "signedHash" : {
          "type" : "string",
          "description" : "SHA256 hash (ie. the fingerprint) of the original signed data."
        },
        "signedIdentity" : {
          "type" : "string",
          "description" : "X500 Distinguished Name representing the signed identity."
        },
        "signedIssuerDomain" : {
          "type" : "string",
          "description" : "Domain name of the identity issuer (ie. of the organization who verified the identity)."
        },
        "pubKey" : {
          "type" : "string",
          "description" : "Public key of the signee.<br>\n**Currently only Bitcoin addresses are supported.**\n"
        },
        "signature" : {
          "type" : "string",
          "description" : "Signature of the `signedHash` property using the public key `pubKey`, or, if any of `signedIdentity` or `signedIssuerDomain` is provided,\nsignature of SHA256(`hashToSign` + `signedIdentity` + `signedIssuerDomain`) using the public key `pubKey`.\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook to use to verify the signee's identity."
        }
      },
      "description" : "For proof of signature receipts only. The anchored signature.",
      "example" : {
        "signedIssuerDomain" : "signedIssuerDomain",
        "signature" : "signature",
        "signedHash" : "signedHash",
        "identityURL" : "identityURL",
        "signedIdentity" : "signedIdentity",
        "pubKey" : "pubKey"
      }
    },
    "receipt_header" : {
      "type" : "object",
      "properties" : {
        "chainpoint_version" : {
          "type" : "string",
          "default" : "1.0"
        },
        "hash_type" : {
          "type" : "string",
          "default" : "SHA-256"
        },
        "merkle_root" : {
          "type" : "string"
        },
        "tx_id" : {
          "type" : "string"
        },
        "timestamp" : {
          "type" : "integer",
          "format" : "int64"
        }
      },
      "description" : "Chainpoint 1.x only",
      "example" : {
        "chainpoint_version" : "1.0",
        "merkle_root" : "merkle_root",
        "tx_id" : "tx_id",
        "hash_type" : "SHA-256",
        "timestamp" : 0
      }
    },
    "receipt_target" : {
      "type" : "object",
      "properties" : {
        "target_hash" : {
          "type" : "string"
        },
        "target_proof" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/receipt_target_proof_node"
          }
        }
      },
      "description" : "Chainpoint 1.x only",
      "example" : {
        "target_hash" : "target_hash",
        "target_proof" : [ {
          "parent" : "parent",
          "left" : "left",
          "right" : "right"
        }, {
          "parent" : "parent",
          "left" : "left",
          "right" : "right"
        } ]
      }
    },
    "receipt_target_proof_node" : {
      "type" : "object",
      "properties" : {
        "left" : {
          "type" : "string"
        },
        "parent" : {
          "type" : "string"
        },
        "right" : {
          "type" : "string"
        }
      },
      "description" : "Chainpoint 1.x only",
      "example" : {
        "parent" : "parent",
        "left" : "left",
        "right" : "right"
      }
    },
    "otsReceipt" : {
      "type" : "string",
      "format" : "binary"
    },
    "signatureRequest" : {
      "type" : "object",
      "required" : [ "hashToSign", "name" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Signature request identifier. It is allocated by the platform, and so must not be provided at creation time.\n",
          "readOnly" : true
        },
        "created" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of creation (in milliseconds since Unix epoch).\n",
          "readOnly" : true
        },
        "lastModified" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of last modification (in milliseconds since Unix epoch).\n",
          "readOnly" : true
        },
        "name" : {
          "type" : "string",
          "description" : "Name of the signature request (doesn't need to be unique).\n"
        },
        "public" : {
          "type" : "boolean",
          "description" : "`true` (or unset) if the signature anchors created in the scope of this signature request must be public (ie. discoverable by their `signedHash`).<br>\n`false` if they must be private (ie. not dicoverable).<br>\n**If this field is not set at creation time, the anchor is public by default.**\n"
        },
        "suspended" : {
          "type" : "boolean",
          "description" : "`true` if the signature request is suspended, or `false` (or unset) if not.<br>\nWhen suspended, no more signature can be registered before the request is resumed.\n"
        },
        "hashToSign" : {
          "type" : "string",
          "description" : "SHA256 hash (ie. the fingerprint) of the original data to sign.\nThe value must be provided as an hexadecimal lowercase string.\n"
        },
        "anchors" : {
          "type" : "array",
          "description" : "List of signature anchors created in teh scope of this signature request<br>\nA signature anchor is created each time a new signature is registered.<br>\nThis property is only available to the owner of the signature request.\n",
          "items" : {
            "$ref" : "#/definitions/anchor"
          }
        },
        "deadline" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Deadline of the signature request (in milliseconds since Unix epoch).<br>\nWhen not set, null or 0, no deadline is applied.<br>\nIf set, signatures registered after the deadline are refused.\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook to use to verify the signee's identity.<br>\nIf set, it is used to verify signees' identity at signature registration time.\n"
        },
        "maxSignatures" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Maximum number of signatures to accept for this signature request.<br>\nWhen not set, null or 0, no maximum is applied.<br>\nThis property and the `authorizedSignees` property are mutually exclusive.<br>\nThis property is only available to the owner of the signature request.\n"
        },
        "authorizedSignees" : {
          "type" : "array",
          "description" : "List of all signees authorized to register their signature for this signature request (no duplicate is authorized).<br>\nWhen not set or null, anybody can sign the signature request.<br>\nIf set, signatures registered by signees not in this list are rejected.<br>\nThis property and the `maxSignatures` property are mutually exclusive.<br>\nThis property is only available to the owner of the signature request.\n",
          "items" : {
            "$ref" : "#/definitions/authorizedSignee"
          }
        }
      },
      "example" : {
        "public" : true,
        "created" : 0,
        "authorizedSignees" : [ {
          "commonName" : "John Doe",
          "countryCallingCode" : "33",
          "phone" : "0612345678",
          "requiresOTP" : true,
          "identityURL" : "identityURL",
          "device" : "SERVER",
          "email" : "john.doe@acme.com",
          "pubKey" : "pubKey"
        }, {
          "commonName" : "John Doe",
          "countryCallingCode" : "33",
          "phone" : "0612345678",
          "requiresOTP" : true,
          "identityURL" : "identityURL",
          "device" : "SERVER",
          "email" : "john.doe@acme.com",
          "pubKey" : "pubKey"
        } ],
        "name" : "name",
        "identityURL" : "identityURL",
        "id" : "id",
        "lastModified" : 6,
        "hashToSign" : "hashToSign",
        "anchors" : [ {
          "metadata" : "{}",
          "signedIssuerDomain" : "signedIssuerDomain",
          "signature" : "signature",
          "created" : 0,
          "notifyByEmail" : true,
          "identityURL" : "identityURL",
          "txId" : "txId",
          "confirmations" : 5,
          "signedIdentity" : "signedIdentity",
          "tags" : [ "tags", "tags" ],
          "public" : true,
          "name" : "name",
          "signedHash" : "signedHash",
          "callbackURL" : "callbackURL",
          "id" : "id",
          "lastModified" : 6,
          "hash" : "hash",
          "pubKey" : "pubKey",
          "status" : "WAIT",
          "timestamp" : 1
        }, {
          "metadata" : "{}",
          "signedIssuerDomain" : "signedIssuerDomain",
          "signature" : "signature",
          "created" : 0,
          "notifyByEmail" : true,
          "identityURL" : "identityURL",
          "txId" : "txId",
          "confirmations" : 5,
          "signedIdentity" : "signedIdentity",
          "tags" : [ "tags", "tags" ],
          "public" : true,
          "name" : "name",
          "signedHash" : "signedHash",
          "callbackURL" : "callbackURL",
          "id" : "id",
          "lastModified" : 6,
          "hash" : "hash",
          "pubKey" : "pubKey",
          "status" : "WAIT",
          "timestamp" : 1
        } ],
        "maxSignatures" : 5,
        "deadline" : 1,
        "suspended" : true
      }
    },
    "signatureRequests" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of signature requests matching the search criteria.\n",
          "items" : {
            "$ref" : "#/definitions/signatureRequest"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of requests in the retrieved page.\n"
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of requests per page.\n"
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0).\n"
        }
      },
      "example" : {
        "number" : 1,
        "last" : true,
        "numberOfElements" : 0,
        "size" : 6,
        "content" : [ {
          "public" : true,
          "created" : 0,
          "authorizedSignees" : [ {
            "commonName" : "John Doe",
            "countryCallingCode" : "33",
            "phone" : "0612345678",
            "requiresOTP" : true,
            "identityURL" : "identityURL",
            "device" : "SERVER",
            "email" : "john.doe@acme.com",
            "pubKey" : "pubKey"
          }, {
            "commonName" : "John Doe",
            "countryCallingCode" : "33",
            "phone" : "0612345678",
            "requiresOTP" : true,
            "identityURL" : "identityURL",
            "device" : "SERVER",
            "email" : "john.doe@acme.com",
            "pubKey" : "pubKey"
          } ],
          "name" : "name",
          "identityURL" : "identityURL",
          "id" : "id",
          "lastModified" : 6,
          "hashToSign" : "hashToSign",
          "anchors" : [ {
            "metadata" : "{}",
            "signedIssuerDomain" : "signedIssuerDomain",
            "signature" : "signature",
            "created" : 0,
            "notifyByEmail" : true,
            "identityURL" : "identityURL",
            "txId" : "txId",
            "confirmations" : 5,
            "signedIdentity" : "signedIdentity",
            "tags" : [ "tags", "tags" ],
            "public" : true,
            "name" : "name",
            "signedHash" : "signedHash",
            "callbackURL" : "callbackURL",
            "id" : "id",
            "lastModified" : 6,
            "hash" : "hash",
            "pubKey" : "pubKey",
            "status" : "WAIT",
            "timestamp" : 1
          }, {
            "metadata" : "{}",
            "signedIssuerDomain" : "signedIssuerDomain",
            "signature" : "signature",
            "created" : 0,
            "notifyByEmail" : true,
            "identityURL" : "identityURL",
            "txId" : "txId",
            "confirmations" : 5,
            "signedIdentity" : "signedIdentity",
            "tags" : [ "tags", "tags" ],
            "public" : true,
            "name" : "name",
            "signedHash" : "signedHash",
            "callbackURL" : "callbackURL",
            "id" : "id",
            "lastModified" : 6,
            "hash" : "hash",
            "pubKey" : "pubKey",
            "status" : "WAIT",
            "timestamp" : 1
          } ],
          "maxSignatures" : 5,
          "deadline" : 1,
          "suspended" : true
        }, {
          "public" : true,
          "created" : 0,
          "authorizedSignees" : [ {
            "commonName" : "John Doe",
            "countryCallingCode" : "33",
            "phone" : "0612345678",
            "requiresOTP" : true,
            "identityURL" : "identityURL",
            "device" : "SERVER",
            "email" : "john.doe@acme.com",
            "pubKey" : "pubKey"
          }, {
            "commonName" : "John Doe",
            "countryCallingCode" : "33",
            "phone" : "0612345678",
            "requiresOTP" : true,
            "identityURL" : "identityURL",
            "device" : "SERVER",
            "email" : "john.doe@acme.com",
            "pubKey" : "pubKey"
          } ],
          "name" : "name",
          "identityURL" : "identityURL",
          "id" : "id",
          "lastModified" : 6,
          "hashToSign" : "hashToSign",
          "anchors" : [ {
            "metadata" : "{}",
            "signedIssuerDomain" : "signedIssuerDomain",
            "signature" : "signature",
            "created" : 0,
            "notifyByEmail" : true,
            "identityURL" : "identityURL",
            "txId" : "txId",
            "confirmations" : 5,
            "signedIdentity" : "signedIdentity",
            "tags" : [ "tags", "tags" ],
            "public" : true,
            "name" : "name",
            "signedHash" : "signedHash",
            "callbackURL" : "callbackURL",
            "id" : "id",
            "lastModified" : 6,
            "hash" : "hash",
            "pubKey" : "pubKey",
            "status" : "WAIT",
            "timestamp" : 1
          }, {
            "metadata" : "{}",
            "signedIssuerDomain" : "signedIssuerDomain",
            "signature" : "signature",
            "created" : 0,
            "notifyByEmail" : true,
            "identityURL" : "identityURL",
            "txId" : "txId",
            "confirmations" : 5,
            "signedIdentity" : "signedIdentity",
            "tags" : [ "tags", "tags" ],
            "public" : true,
            "name" : "name",
            "signedHash" : "signedHash",
            "callbackURL" : "callbackURL",
            "id" : "id",
            "lastModified" : 6,
            "hash" : "hash",
            "pubKey" : "pubKey",
            "status" : "WAIT",
            "timestamp" : 1
          } ],
          "maxSignatures" : 5,
          "deadline" : 1,
          "suspended" : true
        } ],
        "first" : true
      }
    },
    "authorizedSignee" : {
      "type" : "object",
      "properties" : {
        "pubKey" : {
          "type" : "string",
          "description" : "The public key the authorized signee must use to sign.<br>\n**Currently only Bitcoin addresses are supported.**<br>\nIf not set, the authorized signee can sign using any key.\n"
        },
        "device" : {
          "type" : "string",
          "description" : "The type of device the authorized signee should use to sign:<br>\n- SERVER: Woleet.ID Server or equivalent\n- MOBILE: Woleet.ID Mobile or equivalent\n- NANO: Ledger Nano S or equivalent\nIf set, the signature web application could only offer the corresponding signature mode.\n",
          "enum" : [ "SERVER", "MOBILE", "NANO" ]
        },
        "email" : {
          "type" : "string",
          "example" : "john.doe@acme.com",
          "description" : "The email of the authorized signee.<br>\nIf set, an email is sent by the platform to the authorized signee, and `commonName` must also be set.<br>\nIf set, `pubKey` is not mandatory, to allow the authorized signee to sign using any key.\n"
        },
        "countryCallingCode" : {
          "type" : "string",
          "example" : "33",
          "description" : "The country calling code of the authorized signee.\n"
        },
        "phone" : {
          "type" : "string",
          "example" : "0612345678",
          "description" : "The phone of the authorized signee (not including the country calling code).<br>\nThis phone must be able to receive a One Time Password by SMS.\n"
        },
        "requiresOTP" : {
          "type" : "boolean",
          "description" : "`true` if the signee must provide a One Time Password to sign.<br>\nIf `true`, `phone` must be set, since the One Time Password is sent by SMS.\n"
        },
        "commonName" : {
          "type" : "string",
          "example" : "John Doe",
          "description" : "The full name of the authorized signee.\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook to use to verify the signee's identity.<br>\nIf set, it is used to verify signee's identity at signature registration time.\n"
        }
      },
      "example" : {
        "commonName" : "John Doe",
        "countryCallingCode" : "33",
        "phone" : "0612345678",
        "requiresOTP" : true,
        "identityURL" : "identityURL",
        "device" : "SERVER",
        "email" : "john.doe@acme.com",
        "pubKey" : "pubKey"
      }
    },
    "signatureRequestSign" : {
      "type" : "object",
      "required" : [ "pubKey", "signature" ],
      "properties" : {
        "signature" : {
          "type" : "string",
          "description" : "Signature of the `hashToSign` property of the signature request using the public key `pubKey`, or, if any of `signedIdentity` or `signedIssuerDomain` is provided,\nsignature of SHA256(`hashToSign` + `signedIdentity` + `signedIssuerDomain`) using the public key `pubKey`.\n"
        },
        "pubKey" : {
          "type" : "string",
          "description" : "Public key used to sign.\n"
        },
        "signedIdentity" : {
          "type" : "string",
          "description" : "X500 Distinguished Name representing the signed identity.<br>\nIf set, the CN (common name) and EMAILADDRESS (email address) attributes must match the common name and email address of the authorized signee as set in the signature request.\n"
        },
        "signedIssuerDomain" : {
          "type" : "string",
          "description" : "Domain name of the identity issuer (ie. of the organization who verified the identity).<br>\nIf set, the domain name of the identity URL must be included in the `signedIssuerDomain` domain name.\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook to use to verify the signee's identity.<br>\nIf set, it is used in place of the `identityURL` property of the authorized signee to create the signature anchor.\n"
        },
        "device" : {
          "type" : "string",
          "description" : "The type of device the authorized signee used to sign:<br>\n- SERVER: Woleet.ID Server or equivalent\n- MOBILE: Woleet.ID Mobile or equivalent\n- NANO: Ledger Nano S or equivalent\n",
          "enum" : [ "SERVER", "MOBILE", "NANO" ]
        },
        "signeeId" : {
          "type" : "string",
          "description" : "Secret identifier of the signee (only required if `email` was set for this signee).\n"
        },
        "otp" : {
          "type" : "string",
          "description" : "One Time Password of the signee (only required if `requiresOTP` was set to `true` for ths signee).\n"
        }
      }
    },
    "signatureRequestSignResult" : {
      "type" : "object",
      "properties" : {
        "anchorId" : {
          "type" : "string",
          "description" : "Identifier of the signature anchor created.\n"
        }
      },
      "example" : {
        "anchorId" : "anchorId"
      }
    },
    "anchor" : {
      "type" : "object",
      "required" : [ "hash", "name" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Anchor identifier. It is allocated by the platform, and so must not be provided at creation time.\n",
          "readOnly" : true
        },
        "created" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of creation (in milliseconds since Unix epoch).\n",
          "readOnly" : true
        },
        "lastModified" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of last modification (in milliseconds since Unix epoch).\n",
          "readOnly" : true
        },
        "name" : {
          "type" : "string",
          "description" : "Name of the anchor (doesn't need to be unique).\n"
        },
        "hash" : {
          "type" : "string",
          "description" : "SHA256 hash (ie. the fingerprint) of the original data to anchor.<br>\nThe value must be provided as an hexadecimal lowercase string.<br>\n**This property must not be provided when creating a signature anchor: it is set at creation time to the SHA256 hash of the `signature` property provided (so the signature is what is actually anchored in this case).**\n"
        },
        "signedHash" : {
          "type" : "string",
          "description" : "SHA256 hash (ie. the fingerprint) of the original signed data.<br>\nThe value must be provided as an hexadecimal lowercase string.<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "signedIdentity" : {
          "type" : "string",
          "description" : "X500 Distinguished Name representing the signed identity.<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "signedIssuerDomain" : {
          "type" : "string",
          "description" : "Domain name of the identity issuer (ie. of the organization who verified the identity).<br>\nIf set, the domain name of the identity URL must be included in the `signedIssuerDomain` domain name.\n**This property must not be provided when creating a data anchor.**\n"
        },
        "pubKey" : {
          "type" : "string",
          "description" : "Public key of the signee.<br>\n**Currently only Bitcoin addresses are supported.**<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "signature" : {
          "type" : "string",
          "description" : "Signature of the `signedHash` property using the public key `pubKey`, or, if any of `signedIdentity` or `signedIssuerDomain` is provided,\nsignature of SHA256(`hashToSign` + `signedIdentity` + `signedIssuerDomain`) using the public key `pubKey`.<br>\n**Only Bitcoin signatures are currently supported.**<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook of the identity server to use to verify the signee's identity.<br>\nThis URL allows to retrieve the identity associated to the public key `pubKey`.\nIt can also be used to verify that the identity server (itself identified by the TLS certificate of the URL) controls the key used to sign (ie. owns the private part of the key pair) by requesting it to sign some random data.<br>\nThis URL MUST use an HTTPS scheme with a valid and non expired TLS certificate.<br>\nThis URL MUST implement the following GET operation:<br>\nQuery parameters:<br>\n- `pubKey`: the public key to be verified - mandatory<br>\n- `leftData`: the left part of the data to be signed (generated randomly by the caller) - if set, the identity server MAY provide a `signature`<br>\nOutput:<br>\nA JSON object with:\n- `rightData`: the right part of the data signed (generated randomly by the identity server) - optional<br>\n- `signature`: the signature of the string `leftData` + `rightData` using the public key `pubKey` - optional<br>\n- `identity`: the X500 identity associated to the key claimed by the identity server - optional<br>\n- `key`: additional information about the key - optional<br>\nIf `identity` is not provided, `signature` and `rightData` MUST be provided: in such a case the identity of the signee can be extracted from the TLS certificate.\n"
        },
        "public" : {
          "type" : "boolean",
          "description" : "`true` (or unset) if the anchor is public (ie. discoverable by its `hash` or `signedHash`).<br>\n`false` if it must be private (ie. not discoverable).<br>\n**If this field is not set at creation time, the anchor is public by default.**\n"
        },
        "notifyByEmail" : {
          "type" : "boolean",
          "description" : "`true` if the proof receipt must be sent by email once available, or `false` (or unset) if not.\n"
        },
        "tags" : {
          "type" : "array",
          "description" : "Set of tags associated to the anchor. There is no restriction on tag names, except they cannot contain spaces.<br>\nTags are aimed at classifying and searching anchors.\n",
          "items" : {
            "type" : "string"
          }
        },
        "metadata" : {
          "type" : "object",
          "description" : "A JSON object containing a set of key/values to store with the anchor and giving additional information about the anchored data.<br>\nValues must be of type null, boolean, string or number: nested JSON objects are not allowed.<br>\nex: { title: 'Ubik', author: 'Philip K. Dick', read: true, rank: 10.0, coauthor: null }\n",
          "properties" : { }
        },
        "callbackURL" : {
          "type" : "string",
          "description" : "Web hook to be called by the platform whenever the anchor status change:<br>\nthe platform does a POST request on this URL with the anchor as a JSON object in the request body.<br>\nVerifying the authenticity of the callback can be done by checking the HMAC-SHA1 signature of the request body provided by Woleet in the `x-woleet-signature` header.<br>\nFor more information see the <a target=\"_blank\" href=\"https://doc.woleet.io/reference#using-callbacks\">documentation</a>.\n"
        },
        "status" : {
          "type" : "string",
          "description" : "Status of the anchor:<br>\n- WAIT: waiting to be processed by the platform (the proof receipt is not yet available for download)<br>\n- NEW: waiting to be sent to the blockchain (the proof receipt is not yet available for download)<br>\n- SENT: sent to the blockchain (the proof receipt can be downloaded)<br>\n- CONFIRMED: confirmed at least 6 times by the blockchain (the proof receipt can be verified)\n",
          "readOnly" : true,
          "enum" : [ "WAIT", "NEW", "SENT", "CONFIRMED" ]
        },
        "timestamp" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Proven timestamp of the data (for a data anchor) or of the signature (for a signature anchor).<br>\nThis is actually the time of the Bitcoin block into which the anchoring process occurred (in milliseconds since Unix epoch).<br>\nAny data whose SHA256 hash equals this anchor's hash is proven to exist at that time and has not been modified since.<br>\nThis field is set when the first confirmation of the Bitcoin block occurs. Once set, the associated proof receipt can be verified (without having to wait for 6 confirmations).\n",
          "readOnly" : true
        },
        "confirmations" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of confirmations of the Bitcoin block into which the anchoring process occurred.<br>\nThis field is set when the first confirmation of the Bitcoin block occurs, and removed once the block is confirmed at least 6 times.\n",
          "readOnly" : true
        },
        "txId" : {
          "type" : "string",
          "description" : "Identifier of the Bitcoin transaction where the anchoring occurred.\n",
          "readOnly" : true
        }
      },
      "example" : {
        "metadata" : "{}",
        "signedIssuerDomain" : "signedIssuerDomain",
        "signature" : "signature",
        "created" : 0,
        "notifyByEmail" : true,
        "identityURL" : "identityURL",
        "txId" : "txId",
        "confirmations" : 5,
        "signedIdentity" : "signedIdentity",
        "tags" : [ "tags", "tags" ],
        "public" : true,
        "name" : "name",
        "signedHash" : "signedHash",
        "callbackURL" : "callbackURL",
        "id" : "id",
        "lastModified" : 6,
        "hash" : "hash",
        "pubKey" : "pubKey",
        "status" : "WAIT",
        "timestamp" : 1
      }
    },
    "anchors" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of anchors matching the search criteria.",
          "items" : {
            "$ref" : "#/definitions/anchor"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of anchors in the retrieved page."
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of anchors per page."
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0)."
        }
      },
      "example" : {
        "number" : 1,
        "last" : true,
        "numberOfElements" : 0,
        "size" : 6,
        "content" : [ {
          "metadata" : "{}",
          "signedIssuerDomain" : "signedIssuerDomain",
          "signature" : "signature",
          "created" : 0,
          "notifyByEmail" : true,
          "identityURL" : "identityURL",
          "txId" : "txId",
          "confirmations" : 5,
          "signedIdentity" : "signedIdentity",
          "tags" : [ "tags", "tags" ],
          "public" : true,
          "name" : "name",
          "signedHash" : "signedHash",
          "callbackURL" : "callbackURL",
          "id" : "id",
          "lastModified" : 6,
          "hash" : "hash",
          "pubKey" : "pubKey",
          "status" : "WAIT",
          "timestamp" : 1
        }, {
          "metadata" : "{}",
          "signedIssuerDomain" : "signedIssuerDomain",
          "signature" : "signature",
          "created" : 0,
          "notifyByEmail" : true,
          "identityURL" : "identityURL",
          "txId" : "txId",
          "confirmations" : 5,
          "signedIdentity" : "signedIdentity",
          "tags" : [ "tags", "tags" ],
          "public" : true,
          "name" : "name",
          "signedHash" : "signedHash",
          "callbackURL" : "callbackURL",
          "id" : "id",
          "lastModified" : 6,
          "hash" : "hash",
          "pubKey" : "pubKey",
          "status" : "WAIT",
          "timestamp" : 1
        } ],
        "first" : true
      }
    },
    "anchorIds" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of identifiers of anchors matching the search criteria.",
          "items" : {
            "type" : "string"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "totalPages" : {
          "type" : "integer",
          "description" : "Total number of pages available."
        },
        "totalElements" : {
          "type" : "integer",
          "description" : "Total number of anchors matching the search criteria."
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of anchors in the retrieved page."
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of anchors per page."
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0)."
        }
      },
      "example" : {
        "number" : 5,
        "last" : true,
        "numberOfElements" : 1,
        "size" : 5,
        "totalPages" : 0,
        "content" : [ "content", "content" ],
        "first" : true,
        "totalElements" : 6
      }
    },
    "receiptVerificationStatus" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "type" : "string",
          "description" : "Proof receipt verification status code:<br>\n- VERIFIED: the proof receipt is verified<br>\nThe receipt format is valid, the transaction is present in the Bitcoin blockchain and confirmed at least once,\nthe receipt contains a valid Merkle proof linking its `targetHash` property to the transaction's `OP_RETURN` field.<br>\nThe creation time and the number of confirmation of the block containing the transaction is returned\nin the `timestamp` and `confirmations` properties.<br>\nAny data whose SHA256 hash matches the proof receipt's `targetHash` is proven to exist at that time and has not been modified since.<br>\n- TX_NOT_FOUND: the receipt's `anchors` property does not include a valid Bitcoin transaction<br>\n- TX_NOT_CONFIRMED: the transaction is not yet confirmed by the blockchain (ie. not yet included in a block)<br>\n- INVALID_PROOF: the receipt's `proof` property is not a valid Merkle proof<br>\n- TX_MISMATCH_RECEIPT: the receipt's `merkleRoot` property does not match the transaction's `OP_RETURN` field<br>\n- INVALID_SIGNATURE: the receipt's `signature` property is not a valid signature\n",
          "enum" : [ "VERIFIED", "INVALID_PROOF", "TX_NOT_FOUND", "TX_NOT_CONFIRMED", "TX_MISMATCH_RECEIPT", "INVALID_SIGNATURE" ]
        },
        "text" : {
          "type" : "string",
          "description" : "Proof receipt verification status text giving more insight about verification errors."
        },
        "timestamp" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Proven timestamp of the data (for a data anchor) or of the signature (for a signature anchor).<br>\nThis is actually the time of the Bitcoin block into which the anchoring process occurred (in milliseconds since Unix epoch).<br>\nAny data whose SHA256 hash equals this proof receipt's target hash property is proven to exist at that time and has not been modified since.\n"
        },
        "confirmations" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of confirmations of the Bitcoin block into which the anchoring process occurred."
        },
        "identityVerificationStatus" : {
          "$ref" : "#/definitions/identityVerificationStatus"
        }
      },
      "example" : {
        "code" : "VERIFIED",
        "identityVerificationStatus" : {
          "code" : "VERIFIED",
          "signedIssuerDomain" : "signedIssuerDomain",
          "certificates" : [ {
            "subject" : {
              "ST" : "ST",
              "C" : "C",
              "OU" : "OU",
              "EMAILADDRESS" : "EMAILADDRESS",
              "CN" : "CN",
              "L" : "L",
              "O" : "O"
            },
            "issuer" : {
              "ST" : "ST",
              "C" : "C",
              "OU" : "OU",
              "EMAILADDRESS" : "EMAILADDRESS",
              "CN" : "CN",
              "L" : "L",
              "O" : "O"
            }
          }, {
            "subject" : {
              "ST" : "ST",
              "C" : "C",
              "OU" : "OU",
              "EMAILADDRESS" : "EMAILADDRESS",
              "CN" : "CN",
              "L" : "L",
              "O" : "O"
            },
            "issuer" : {
              "ST" : "ST",
              "C" : "C",
              "OU" : "OU",
              "EMAILADDRESS" : "EMAILADDRESS",
              "CN" : "CN",
              "L" : "L",
              "O" : "O"
            }
          } ],
          "identity" : {
            "commonName" : "Jim Smith",
            "country" : "FR",
            "organization" : "Woleet",
            "locality" : "Rennes",
            "organizationalUnit" : "Sales"
          },
          "text" : "text",
          "signedIdentity" : {
            "commonName" : "Jim Smith",
            "country" : "FR",
            "organization" : "Woleet",
            "locality" : "Rennes",
            "organizationalUnit" : "Sales"
          }
        },
        "text" : "text",
        "confirmations" : 6,
        "timestamp" : 0
      }
    },
    "identityVerificationStatus" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "type" : "string",
          "description" : "Identity verification status code:<br>\n- VERIFIED: the key is controlled by the identity server,<br>\nand/or the key is associated to an identity on the identity server,<br>\nand/or the identity is included in the anchored signature,<br>\nand/or the signed identity matches the one claimed by the identity server,<br>\n- IDENTITY_MISMATCH: the identity included in the anchored signature mismatch the identity claimed by the identity server<br>\n- INVALID_SIGNATURE: the identity URL returned an invalid signature (ie. the identity server failed to prove that it owns the private part of key pair)<br>\n- HTTP_ERROR: the identity URL returned an HTTP error\n",
          "enum" : [ "VERIFIED", "HTTP_ERROR", "IDENTITY_MISMATCH", "INVALID_SIGNATURE" ]
        },
        "text" : {
          "type" : "string",
          "description" : "Identity verification status text (gives more insights about the verification process)."
        },
        "certificates" : {
          "type" : "array",
          "description" : "Array of subjects and issuers of the certificates extracted from the identity URL's TLS certificate.",
          "items" : {
            "$ref" : "#/definitions/X509SubjectIssuer"
          }
        },
        "identity" : {
          "description" : "X500 identity of the signee as claimed by the identity server.",
          "$ref" : "#/definitions/identity"
        },
        "signedIdentity" : {
          "description" : "X500 identity of the signee as included in the anchored signature (deserialized from the X500 Distinguished Name) .",
          "$ref" : "#/definitions/identity"
        },
        "signedIssuerDomain" : {
          "type" : "string",
          "description" : "Domain name of the identity issuer (ie. of the organization who verified the identity)."
        }
      },
      "example" : {
        "code" : "VERIFIED",
        "signedIssuerDomain" : "signedIssuerDomain",
        "certificates" : [ {
          "subject" : {
            "ST" : "ST",
            "C" : "C",
            "OU" : "OU",
            "EMAILADDRESS" : "EMAILADDRESS",
            "CN" : "CN",
            "L" : "L",
            "O" : "O"
          },
          "issuer" : {
            "ST" : "ST",
            "C" : "C",
            "OU" : "OU",
            "EMAILADDRESS" : "EMAILADDRESS",
            "CN" : "CN",
            "L" : "L",
            "O" : "O"
          }
        }, {
          "subject" : {
            "ST" : "ST",
            "C" : "C",
            "OU" : "OU",
            "EMAILADDRESS" : "EMAILADDRESS",
            "CN" : "CN",
            "L" : "L",
            "O" : "O"
          },
          "issuer" : {
            "ST" : "ST",
            "C" : "C",
            "OU" : "OU",
            "EMAILADDRESS" : "EMAILADDRESS",
            "CN" : "CN",
            "L" : "L",
            "O" : "O"
          }
        } ],
        "identity" : {
          "commonName" : "Jim Smith",
          "country" : "FR",
          "organization" : "Woleet",
          "locality" : "Rennes",
          "organizationalUnit" : "Sales"
        },
        "text" : "text",
        "signedIdentity" : {
          "commonName" : "Jim Smith",
          "country" : "FR",
          "organization" : "Woleet",
          "locality" : "Rennes",
          "organizationalUnit" : "Sales"
        }
      }
    },
    "X509SubjectIssuer" : {
      "type" : "object",
      "properties" : {
        "subject" : {
          "$ref" : "#/definitions/X500Name"
        },
        "issuer" : {
          "$ref" : "#/definitions/X500Name"
        }
      },
      "example" : {
        "subject" : {
          "ST" : "ST",
          "C" : "C",
          "OU" : "OU",
          "EMAILADDRESS" : "EMAILADDRESS",
          "CN" : "CN",
          "L" : "L",
          "O" : "O"
        },
        "issuer" : {
          "ST" : "ST",
          "C" : "C",
          "OU" : "OU",
          "EMAILADDRESS" : "EMAILADDRESS",
          "CN" : "CN",
          "L" : "L",
          "O" : "O"
        }
      }
    },
    "X500Name" : {
      "type" : "object",
      "properties" : {
        "C" : {
          "type" : "string",
          "description" : "Country code"
        },
        "ST" : {
          "type" : "string",
          "description" : "State or Province"
        },
        "L" : {
          "type" : "string",
          "description" : "Locality"
        },
        "O" : {
          "type" : "string",
          "description" : "Organization"
        },
        "OU" : {
          "type" : "string",
          "description" : "Organizational Unit"
        },
        "CN" : {
          "type" : "string",
          "description" : "Common Name"
        },
        "EMAILADDRESS" : {
          "type" : "string",
          "description" : "Email address"
        }
      },
      "description" : "X500 Distinguished Name.",
      "example" : {
        "ST" : "ST",
        "C" : "C",
        "OU" : "OU",
        "EMAILADDRESS" : "EMAILADDRESS",
        "CN" : "CN",
        "L" : "L",
        "O" : "O"
      }
    },
    "identity" : {
      "type" : "object",
      "required" : [ "commonName" ],
      "properties" : {
        "commonName" : {
          "type" : "string",
          "example" : "Jim Smith",
          "description" : "commonName (CN) (2.5.4.3)"
        },
        "organization" : {
          "type" : "string",
          "example" : "Woleet",
          "description" : "organizationName (O) (2.5.4.10)"
        },
        "organizationalUnit" : {
          "type" : "string",
          "example" : "Sales",
          "description" : "organizationalUnitName (OU) (2.5.4.11)"
        },
        "locality" : {
          "type" : "string",
          "example" : "Rennes",
          "description" : "localityName (L) (2.5.4.7)"
        },
        "country" : {
          "type" : "string",
          "example" : "FR",
          "description" : "countryName (C) (2.5.4.6)"
        }
      },
      "description" : "Signee's identity provided as a set of X.500 attributes (see https://www.ietf.org/rfc/rfc4519.txt).",
      "example" : {
        "commonName" : "Jim Smith",
        "country" : "FR",
        "organization" : "Woleet",
        "locality" : "Rennes",
        "organizationalUnit" : "Sales"
      }
    },
    "token" : {
      "type" : "object",
      "properties" : {
        "token" : {
          "type" : "string",
          "description" : "The JWT token value to provide in the `Bearer` scheme of the `Authorization` header."
        }
      },
      "example" : {
        "token" : "token"
      }
    },
    "credits" : {
      "type" : "object",
      "properties" : {
        "credits" : {
          "type" : "integer",
          "description" : "The remaining number of anchoring credits of the authenticated user's account."
        },
        "signCredits" : {
          "type" : "integer",
          "description" : "The remaining number of signature credits of the authenticated user's account."
        }
      },
      "example" : {
        "signCredits" : 6,
        "credits" : 0
      }
    },
    "user" : {
      "type" : "object",
      "required" : [ "email", "info", "password", "roles", "status" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "User identifier. It is allocated by the platform, and so must not be provided at creation time.\n",
          "readOnly" : true
        },
        "created" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of creation (in milliseconds since Unix epoch).\n",
          "readOnly" : true
        },
        "lastModified" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of last modification (in milliseconds since Unix epoch).\n",
          "readOnly" : true
        },
        "email" : {
          "type" : "string",
          "description" : "Email of the user.\n"
        },
        "password" : {
          "type" : "string",
          "description" : "Password of the user (it must be provided at creation time).\n"
        },
        "roles" : {
          "type" : "array",
          "description" : "The roles of the user:<br>\n- ROLE_USER: regular user<br>\n- ROLE_DOMAIN_ADMIN: domain administrator.\n",
          "items" : {
            "type" : "string",
            "enum" : [ "ROLE_USER", "ROLE_DOMAIN_ADMIN" ],
            "default" : "ROLE_USER"
          }
        },
        "info" : {
          "type" : "object",
          "description" : "Object storing meta data about the user. Some property names are reserved, but properties are not limitted to the one listed here.\n",
          "additionalProperties" : {
            "type" : "object",
            "description" : "Other information about the user.\n",
            "properties" : { }
          }
        },
        "status" : {
          "type" : "string",
          "description" : "The status of the user:<br>\n- PENDING: the user email need to be validated<br>\n- APPROVED: the user can loging<br>\n- DISABLED: the user cannot login\n",
          "enum" : [ "PENDING", "APPROVED", "DISABLED" ],
          "default" : "PENDING"
        }
      },
      "example" : {
        "password" : "password",
        "created" : 0,
        "roles" : [ "ROLE_USER", "ROLE_USER" ],
        "id" : "id",
        "lastModified" : 6,
        "email" : "email",
        "info" : {
          "key" : "{}"
        },
        "status" : "PENDING"
      }
    },
    "users" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of users matching the search criteria.",
          "items" : {
            "$ref" : "#/definitions/user"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of users in the retrieved page."
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of users per page."
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0)."
        }
      },
      "example" : {
        "number" : 1,
        "last" : true,
        "numberOfElements" : 0,
        "size" : 6,
        "content" : [ {
          "password" : "password",
          "created" : 0,
          "roles" : [ "ROLE_USER", "ROLE_USER" ],
          "id" : "id",
          "lastModified" : 6,
          "email" : "email",
          "info" : {
            "key" : "{}"
          },
          "status" : "PENDING"
        }, {
          "password" : "password",
          "created" : 0,
          "roles" : [ "ROLE_USER", "ROLE_USER" ],
          "id" : "id",
          "lastModified" : 6,
          "email" : "email",
          "info" : {
            "key" : "{}"
          },
          "status" : "PENDING"
        } ],
        "first" : true
      }
    },
    "callbackSecret" : {
      "type" : "object",
      "properties" : {
        "secret" : {
          "type" : "string",
          "description" : "The secret used to sign the callback."
        }
      },
      "example" : {
        "secret" : "secret"
      }
    },
    "tokens" : {
      "type" : "object",
      "properties" : {
        "tokens" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      }
    }
  },
  "x-samples-languages" : [ "curl", "javascript", "node", "java", "python", "php" ]
}