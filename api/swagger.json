{
  "swagger" : "2.0",
  "info" : {
    "description" : "Welcome to **Woleet API reference documentation**.<br>\nIt is highly recommanded to read the chapters **[introducing Woleet API concepts](https://doc.woleet.io/reference)** before reading this documentation.\n",
    "version" : "1.7.5",
    "title" : "Woleet API",
    "termsOfService" : "https://doc.woleet.io/docs/terms-of-service",
    "contact" : {
      "url" : "https://www.woleet.io/",
      "email" : "contact@woleet.com"
    }
  },
  "host" : "api.woleet.io",
  "basePath" : "/v1",
  "tags" : [ {
    "name" : "anchor",
    "description" : "Create and manage anchors."
  }, {
    "name" : "receipt",
    "description" : "Get and verify proof receipts."
  }, {
    "name" : "signatureRequest",
    "description" : "Create and manage signature requests."
  }, {
    "name" : "token",
    "description" : "Create and revoke JWT tokens."
  }, {
    "name" : "user",
    "description" : "Manage user information."
  }, {
    "name" : "domain",
    "description" : "Manage domain users."
  } ],
  "schemes" : [ "https" ],
  "consumes" : [ "application/json" ],
  "produces" : [ "application/json" ],
  "security" : [ {
    "BasicAuth" : [ ]
  }, {
    "JWTAuth" : [ ]
  } ],
  "paths" : {
    "/anchor" : {
      "post" : {
        "tags" : [ "anchor" ],
        "summary" : "Create a new anchor.",
        "description" : "Use this operation to create a new anchor of one of these two types:<br>\n\n- a data anchor (generating a proof of existence receipt) allows to prove the existence of some data at some point in time.<br>\n- a signature anchor (generating a proof of signature receipt) allows to prove the existence of the signature of some data at some point in time, the validity of the signature and the signer's identity.<br>\n\nThe properties `id`, `created`, `lastModified`, `status`, `timestamp` and `confirmations` are read-only and so must not be provided: they are managed by the platform and added to the returned anchor.<br>\nFor data anchors, only the properties `name` and `hash` are required: the `hash` property must be the SHA256 hash of the data to anchor, and must be computed caller side. This allows not to leak the original data.<br>\nFor signature anchors, only the properties `name`, `signedHash`, `signature` and `pubKey` are required (though the `identityURL` property is highly recommended): the `signedHash` property must be the SHA256 hash of the data to sign. This allows not to leak the original data and to keep the actual signed data small (signing the digest is equivalent to signing the original data).<br>\nBe sure to have at least 1 anchoring credit on your account. The `signature` property must contain a valid signature of the `data` property using the private key paired with the `pubKey` public key.\n",
        "operationId" : "createAnchor",
        "parameters" : [ {
          "in" : "body",
          "name" : "anchor",
          "description" : "Anchor object to create.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/anchor"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The created anchor.<br>\nNote that for signature anchors, the `hash` property is automatically set to the SHA256 of the signature, which is what is actually anchored into the blockchain).\n",
            "schema" : {
              "$ref" : "#/definitions/anchor"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "402" : {
            "description" : "Insufficient credits."
          }
        }
      }
    },
    "/anchor/{anchorId}" : {
      "get" : {
        "tags" : [ "anchor" ],
        "summary" : "Get an anchor by its identifier.",
        "description" : "Use this operation to retrieve an anchor by its identifier.",
        "operationId" : "getAnchor",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor to retrieve.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The anchor.",
            "schema" : {
              "$ref" : "#/definitions/anchor"
            }
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        }
      },
      "put" : {
        "tags" : [ "anchor" ],
        "summary" : "Update an anchor.",
        "description" : "Use this operation to update an anchor.<br>\nOnly the properties `name`, `public`, `tags`, `metadata` and `callbackURL` can be modified.\n",
        "operationId" : "updateAnchor",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of anchor to update.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "anchor",
          "description" : "Anchor object to update.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/anchor"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The updated anchor.",
            "schema" : {
              "$ref" : "#/definitions/anchor"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        }
      },
      "delete" : {
        "tags" : [ "anchor" ],
        "summary" : "Delete an anchor.",
        "description" : "Use this operation to delete an anchor.<br>\n**WARNING: You should never delete an anchor, otherwise you will no longer be able to download its proof receipt.<br>\nUse this for test purpose only.**\n",
        "operationId" : "deleteAnchor",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor to delete.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The anchor is deleted."
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        }
      }
    },
    "/anchor/{anchorId}/attestation" : {
      "get" : {
        "tags" : [ "anchor" ],
        "summary" : "Download the Proof Attestation document of an anchor.",
        "description" : "Use this operation to retrieve the Proof Attestation document of an anchor.<br>\nThis PDF file is available only once the anchor is CONFIRMED.\n",
        "operationId" : "getAnchorAttestation",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Download successful.",
            "schema" : {
              "$ref" : "#/definitions/pdfFile"
            }
          },
          "400" : {
            "description" : "Proof attestation not yet available."
          },
          "404" : {
            "description" : "Anchor not found."
          }
        }
      }
    },
    "/anchorIds" : {
      "get" : {
        "tags" : [ "anchor" ],
        "summary" : "Search for public anchor identifiers.",
        "description" : "Use this operation to retrieve the identifiers of all public anchors having a given `hash` and/or `signedHash` property.<br>\nOnly public anchor identifiers are returned.<br>\nThis is a publicly accessible endpoint: authentication is not required to retrieve public anchor identifiers.<br>\nPaging is supported.\n",
        "operationId" : "searchAnchorIds",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of anchor identifiers per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "hash",
          "in" : "query",
          "description" : "`hash` to search for: all public anchors whose `hash` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "signedHash",
          "in" : "query",
          "description" : "`signedHash` to search for: all public anchors whose `signedHash` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "An array (possibly empty) of the identifiers of all public anchors matching all search criteria, plus additional paging information.",
            "schema" : {
              "$ref" : "#/definitions/anchorIds"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        },
        "security" : [ ]
      }
    },
    "/anchors" : {
      "get" : {
        "tags" : [ "anchor" ],
        "summary" : "Search for anchors.",
        "description" : "Use this operation to retrieve all anchors having a given `name`, `hash`, `signedHash` and/or `tags` property.<br>\nOnly anchors belonging to the authenticated user are returned.<br>\nPaging and sorting is supported.\n",
        "operationId" : "searchAnchors",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of anchors per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "direction",
          "in" : "query",
          "description" : "Sorting direction: ASC for ascending DESC for descending.\n",
          "required" : false,
          "type" : "string",
          "default" : "ASC",
          "enum" : [ "ASC", "DESC" ]
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sorting property: possible values are limited to `id`, `created`, `hash` and `signedHash`.\n",
          "required" : false,
          "type" : "string",
          "default" : "created",
          "enum" : [ "id", "created", "hash", "signedHash" ]
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "`name` to search for: all anchors whose `name` property contains this sub-string are returned.<br>\n**WARNING: Searching by name can timeout on a large anchor set.**\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "hash",
          "in" : "query",
          "description" : "`hash` to search for: all anchors whose `hash` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "signedHash",
          "in" : "query",
          "description" : "`signedHash` to search for: all anchors whose `signedHash` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "tags",
          "in" : "query",
          "description" : "`tags` to search for: all anchors having all of these tags sets are returned.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An array (possibly empty) of all anchors matching all search criteria, plus additional paging and sorting information.",
            "schema" : {
              "$ref" : "#/definitions/anchors"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "504" : {
            "description" : "Can be triggered when searching by name if the request takes too long to process."
          }
        }
      }
    },
    "/receipt/{anchorId}" : {
      "get" : {
        "tags" : [ "receipt" ],
        "summary" : "Get the proof receipt of an anchor (Chainpoint 2.x proof format).",
        "description" : "Use this operation to retrieve the Chainpoint 2.x proof receipt associated to a given anchor.<br>\nThis JSON file is available only once the anchor status is SENT.<br>\nThis is a publicly accessible endpoint: authentication is not required to retrieve a proof receipt (but the anchor identifier need to be known).\n",
        "operationId" : "getReceipt",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor for which to build the proof receipt.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The proof receipt (conform to the Chainpoint 2.x format).",
            "schema" : {
              "$ref" : "#/definitions/receipt"
            }
          },
          "202" : {
            "description" : "The proof receipt is not yet ready for this anchor."
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        },
        "security" : [ ]
      }
    },
    "/receipt/{anchorId}/ots" : {
      "get" : {
        "tags" : [ "receipt" ],
        "summary" : "Get the proof receipt of an anchor (OpenTimestamps proof format).",
        "description" : "Use this operation to retrieve the OpenTimestamps proof receipt associated to a given anchor.<br>\nThis binary file is available only once the anchor status is SENT.<br>\nThis is a publicly accessible endpoint: authentication is not required to retrieve a proof receipt (but the anchor identifier need to be known).\n",
        "operationId" : "getOTSReceipt",
        "parameters" : [ {
          "name" : "anchorId",
          "in" : "path",
          "description" : "Identifier of the anchor for which to build the proof receipt.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The proof receipt (conform to the OpenTimestamps format).",
            "schema" : {
              "$ref" : "#/definitions/otsReceipt"
            }
          },
          "202" : {
            "description" : "The proof receipt is not yet ready for this anchor."
          },
          "404" : {
            "description" : "No anchor matching the given identifier."
          }
        },
        "security" : [ ]
      }
    },
    "/receipt/verify" : {
      "post" : {
        "tags" : [ "receipt" ],
        "summary" : "Verify a proof receipt.",
        "description" : "Use this operation to verify a Chainpoint 2.x proof receipt and get the timestamp of the proof.<br>\nFor proof of signature receipts including an identity URL, this operation also verify and returns information about the signer's identity.<br>\nThis is a publicly accessible endpoint: authentication is not required to verify a proof receipt.\n",
        "operationId" : "verifyReceipt",
        "parameters" : [ {
          "in" : "body",
          "name" : "receipt",
          "description" : "Chainpoint 2.x proof receipt to verify.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/receipt"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The proof receipt verification status.",
            "schema" : {
              "$ref" : "#/definitions/receiptVerificationStatus"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest" : {
      "post" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Create a new signature request.",
        "description" : "Use this operation to create a new signature request.<br>\nThe properties `id`, `created` and `lastModified` are read-only and so must not be provided: they are managed by the platform and added to the returned request.<br>\nOnly the properties `name` and `hashToSign` are required: the `hashToSign` property must be the SHA256 hash of the file to sign.<br>\nBe sure to have enough signature and anchoring credits on your account to fulfill the signature request (each registered signature costs you 1 signature and 1 anchoring credit).<br>\n",
        "operationId" : "createSignatureRequest",
        "parameters" : [ {
          "in" : "body",
          "name" : "signatureRequest",
          "description" : "SignatureRequest object to create.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The created signature request.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequest"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        }
      }
    },
    "/signatureRequest/{requestId}/transition" : {
      "post" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Change the state of a signature request.",
        "description" : "Use this operation to transition a signature request to a new state.<br>\nPossible transitions are:<br>\n- from DRAFT to PENDING: start the signature request: the platform wait for the activation date (if any) and transition to IN_PROGRESS<br>\n- from PENDING to DRAFT: suspend the signature request: allow it to be updated<br>\n- from PENDING to CANCELED: cancel the signature request without waiting for the  activation date<br>\n- from IN_PROGRESS to CLOSED: close the signature request without waiting for all signatures to be colleted<br>\n- from IN_PROGRESS to CANCELED: cancel the signature request before all signatures get colleted\n",
        "operationId" : "transitionSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "state",
          "description" : "New state of the signature request.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequestState"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The transitioned signature request.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequest"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "404" : {
            "description" : "Signature request not found."
          }
        }
      }
    },
    "/signatureRequest/{requestId}/otp/{signeeId}" : {
      "get" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Generate and send an OTP to a signer of a signature request.",
        "description" : "Use this operation to generate and send a new OTP (One Time Password) by SMS to a signer of a signature request.<br>\nThis OTP can be used to sign during a maximum period of 10 mn.\n",
        "operationId" : "sendSignatureRequestOTP",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "signeeId",
          "in" : "path",
          "description" : "Secret identifier of the signer wanting to retrieve his/her OTP.<br>\n**This secret identifier is generated by the platform and provided by email to the signer only.\nIt allows the platform to authenticate the signer and verify his/her email address.**\n",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "OTP succesfully generated and sent by SMS to the signer."
          },
          "401" : {
            "description" : "Unauthorized. The signer is not an authorized signer (secret signer identifier not found)."
          },
          "403" : {
            "description" : "Forbidden. The signature request is not in progress, or the signer does not require an OTP."
          },
          "404" : {
            "description" : "Signature request not found."
          },
          "429" : {
            "description" : "Too many requests. A minimum delay of 1 second is required between two OTP generation."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest/{requestId}/sign" : {
      "post" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Sign a signature request by registering a signature.",
        "description" : "A signer can use this operation to sign a signature request by registering a signature he/she procuded on his/her own.<br>\nThe signature is automatically anchored on behalf of the owner of the signature request.<br>\nThe signature anchor created is added to the list of signature anchors of the signature request.<br>\nThis is a publicly accessible endpoint: authentication is not required to register a signature\n(authentication of the signers, when required, rely on their knowledge of their secret identifier and OTP, or on their control of their public key).\n",
        "operationId" : "signSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "signature",
          "description" : "Signature to register.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequestSign"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Signature succesfully registered. The signature anchor created is returned.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequestSignResult"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "401" : {
            "description" : "Unauthorized. The signer is not an authorized signer (public key or secret signer identifier not found, or invalid OTP)."
          },
          "402" : {
            "description" : "Insufficient credits. The owner of the signature request runs out of signature or anchoring credit."
          },
          "403" : {
            "description" : "Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired."
          },
          "404" : {
            "description" : "Signature request not found."
          },
          "409" : {
            "description" : "Conflict. The signer has already signed."
          },
          "429" : {
            "description" : "Too many requests. A minimum delay of 1 second is required after providing an invalid OTP."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest/{requestId}/delegate" : {
      "post" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Sign a signature request by delegating the signature.",
        "description" : "A signer can use this operation to sign a signature request by delegating the signature to the platform.<br>\nThis operation is only available when the email of the signer is set: since the secret identifier is sent by email to the signer, he/she can provide it back to authenticate.<br>\nWhen using this signature mode, the signer's identity and signature key is controled by the platform, which act as a trusted third party.<br>\nThe signature is automatically anchored on behalf of the owner of the signature request.<br>\nThe signature anchor created is added to the list of signature anchors of the signature request.<br>\nThis is a publicly accessible endpoint: authentication is not required to delegate a signature\n(authentication of the signers, when required, rely on their knowledge of their secret identifier and OTP, or on their control of their public key).\n",
        "operationId" : "delegateSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "delegate",
          "description" : "Authentication information about the signer.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequestDelegate"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Signature succesfully delegated. The signature anchor created is returned.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequestSignResult"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "401" : {
            "description" : "Unauthorized. The signer is not an authorized signer (secret signer identifier not found, or invalid OTP)."
          },
          "402" : {
            "description" : "Insufficient credits. The owner of the signature request runs out of signature or anchoring credit."
          },
          "403" : {
            "description" : "Forbidden. The signature request is not in progress, the maximum number of signatures has been reached or the OTP has expired."
          },
          "404" : {
            "description" : "Signature request not found."
          },
          "409" : {
            "description" : "Conflict. The signer has already signed."
          },
          "429" : {
            "description" : "Too many requests. A minimum delay of 1 second is required after providing an invalid OTP."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest/{requestId}/feedback" : {
      "post" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Report feedback about a signature request.",
        "description" : "A signer can use this operation to report a feedback to the owner of a signature request.<br>\nThis operation is only available when the email of the signer is set: since the secret identifier is sent by email to the signer, he/she can provide it back to authenticate.<br>\nThis is a publicly accessible endpoint: authentication is not required to report feedback\n(authentication of the signers, when required, rely on their knowledge of their secret identifier).\n",
        "operationId" : "feedbackSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "feedback",
          "description" : "Feedback to report.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequestFeedback"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Feedback succesfully reported."
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "401" : {
            "description" : "Unauthorized. The signer is not an authorized signer (secret signer identifier not found)."
          },
          "404" : {
            "description" : "Signature request not found."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest/{requestId}/attestation" : {
      "get" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Download the Signature Attestation document of a signature request.",
        "description" : "Use this operation to retrieve the Signature Attestation document of a signature request.<br>\nThis PDF file is only available once all the following conditions are met:<br>\n- the signature request is COMPLETED (by the platform) or CLOSED (by the requester)<br>\n- the audit trail of the signature request is generated and signed by the platform and its proof receipt is available<br>\nOnce these conditions are met, the platform generates and signs the signature attestation and set the `attestationAnchorId` property.<br>\nThis is a publicly accessible endpoint: authentication is not required to retrieve a signature attestation (but the signature request identifier need to be known).\n",
        "operationId" : "getSignatureRequestAttestation",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Download successful.",
            "schema" : {
              "$ref" : "#/definitions/pdfFile"
            }
          },
          "400" : {
            "description" : "Signature attestation not yet available."
          },
          "404" : {
            "description" : "Signature request not found."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequest/{requestId}" : {
      "get" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Get a signature request by its identifier.",
        "description" : "Use this operation to retrieve a signature request by its identifier.",
        "operationId" : "getSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request to retrieve.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "signeeId",
          "in" : "query",
          "description" : "Secret identifier of the signer wanting to retrieve the signature request.<br>\nIf set, information related to this signer is guaranteed to be returned in `authorizedSignees[0]`.<br>\n**This secret identifier is generated by the platform and provided by email to the signer only.\nIt allows the platform to authenticate the signer and verify his/her email address.**\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The signature request.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequest"
            }
          },
          "404" : {
            "description" : "No signature request matching the given identifier."
          }
        }
      },
      "put" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Update a signature request.",
        "description" : "Use this operation to update a signature request.<br>\nOnly the properties `name`, `public`, `callbackURL`, `activation`, `deadline`, `identityURL`, `fileName`, `fileURL`, `lang`, `vars`, `maxSignatures` and `authorizedSignees` can be modified.\n",
        "operationId" : "updateSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of signature request to update.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "request",
          "description" : "SignatureRequest object to update.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/signatureRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The updated signature request.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequest"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "404" : {
            "description" : "No signature request matching the given identifier."
          }
        }
      },
      "delete" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Delete a signature request.",
        "description" : "Use this operation to delete a signature request.",
        "operationId" : "deleteSignatureRequest",
        "parameters" : [ {
          "name" : "requestId",
          "in" : "path",
          "description" : "Identifier of the signature request to delete.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The signature request is deleted."
          },
          "404" : {
            "description" : "No signature request matching the given identifier."
          }
        }
      }
    },
    "/signatureRequestIds" : {
      "get" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Search for public signature request identifiers.",
        "description" : "Use this operation to retrieve the identifiers of all public signature requests having a given `hashToSign` property.<br>\nOnly public signature request identifiers are returned.<br>\nThis is a publicly accessible endpoint: authentication is not required to retrieve public signature request identifiers.<br>\nPaging is supported.\n",
        "operationId" : "searchSignatureRequestIds",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of signature request identifiers per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "hashToSign",
          "in" : "query",
          "description" : "`hashToSign` to search for: all public signature requests whose `hashToSign` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "An array (possibly empty) of the identifiers of all public signature requests matching all search criteria, plus additional paging information.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequestIds"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        },
        "security" : [ ]
      }
    },
    "/signatureRequests" : {
      "get" : {
        "tags" : [ "signatureRequest" ],
        "summary" : "Search for signature requests.",
        "description" : "Use this operation to retrieve all signature requests having a given `name` and/or `hashToSign` property.<br>\nOnly requests belonging to the authenticated user are returned.<br>\nPaging and sorting is supported.\n",
        "operationId" : "searchSignatureRequests",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of anchors per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "direction",
          "in" : "query",
          "description" : "Sorting direction: ASC for ascending DESC for descending.\n",
          "required" : false,
          "type" : "string",
          "default" : "ASC",
          "enum" : [ "ASC", "DESC" ]
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sorting property: possible values are limited to `id`, `created` and `hashToSign`.\n",
          "required" : false,
          "type" : "string",
          "default" : "created",
          "enum" : [ "id", "created", "hashToSign" ]
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "`name` to search for: all signature requests whose `name` property contains this sub-string are returned.<br>\n**WARNING: Searching by name can timeout on a large signature request set.**\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "hashToSign",
          "in" : "query",
          "description" : "`hashToSign` to search for: all signature requests whose `hashToSign` property is equal are returned.\n",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "state",
          "in" : "query",
          "description" : "`state` to search for: all signature requests having one of those state are returned.\n",
          "required" : false,
          "type" : "array",
          "items" : {
            "type" : "string",
            "enum" : [ "DRAFT", "PENDING", "IN_PROGRESS", "COMPLETED", "CLOSED", "CANCELED", "EXPIRED" ]
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "An array (possibly empty) of all signature requests matching all search criteria, plus additional paging and sorting information.",
            "schema" : {
              "$ref" : "#/definitions/signatureRequests"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "504" : {
            "description" : "Can be triggered when searching by name if the request takes too long to process."
          }
        }
      }
    },
    "/token" : {
      "get" : {
        "tags" : [ "token" ],
        "summary" : "Generate a JWT token.",
        "description" : "Use this operation to generate a new JWT token.<br>\nJWT tokens can be used to authenticate to the API, using the `Bearer` scheme of the `Authorization` header, like:<br>\n`Authorization: Bearer {JWT token}`\n",
        "operationId" : "generateToken",
        "parameters" : [ {
          "name" : "cdata",
          "in" : "query",
          "description" : "Client data to inject into the generated JWT token (64 characters max).<br>\nThis data is not processed by the platform, and can be easily retrieved from the token by Base64 decoding its `payload`.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The JWT token.",
            "schema" : {
              "$ref" : "#/definitions/token"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        }
      },
      "delete" : {
        "tags" : [ "token" ],
        "summary" : "Revoke a JWT token.",
        "description" : "Use this operation to revoke a JWT token.<br>\nJWT tokens have no expiration date so are always valid: if you need to invalidate a token (eg. because you think it is compromised) you need to use this endpoint to inform the platform that this token must no longer be accepted.\n",
        "operationId" : "revokeToken",
        "parameters" : [ {
          "name" : "token",
          "in" : "query",
          "description" : "JWT token to revoke.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The JWT token is revoked."
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        }
      }
    },
    "/user/credits" : {
      "get" : {
        "tags" : [ "user" ],
        "summary" : "Get user's credits.",
        "description" : "Use this operation to get the remaining signature and anchoring credits of the authenticated user.",
        "operationId" : "getCredits",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The remaining signature and anchoring credits.",
            "schema" : {
              "$ref" : "#/definitions/credits"
            }
          }
        }
      }
    },
    "/user/tokens" : {
      "get" : {
        "tags" : [ "user" ],
        "summary" : "Get user's registered JWT tokens.",
        "description" : "Use this operation to list all JWT tokens registered for the authenticated user.",
        "operationId" : "getTokens",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The list of JWT tokens of the user, possibly empty.",
            "schema" : {
              "type" : "array",
              "items" : {
                "type" : "string"
              }
            }
          }
        }
      },
      "put" : {
        "tags" : [ "user" ],
        "summary" : "Update user's registered JWT tokens.",
        "description" : "Use this operation to update the list of JWT tokens registered for the authenticated user.",
        "operationId" : "putTokens",
        "parameters" : [ {
          "in" : "body",
          "name" : "tokens",
          "description" : "The list of JWT tokens to updated.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/tokens"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The list of JWT tokens has been successfully updated."
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        }
      }
    },
    "/user/callbackSecret" : {
      "get" : {
        "tags" : [ "user" ],
        "summary" : "Get the currently used callback secret (null if not set).",
        "description" : "Use this operation to get the api callback secret.",
        "operationId" : "getCallbackSecret",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The currently used callback secret.",
            "schema" : {
              "$ref" : "#/definitions/callbackSecret"
            }
          }
        }
      },
      "put" : {
        "tags" : [ "user" ],
        "summary" : "Generates a new callback secret.",
        "description" : "Use this operation to generate the api callback secret.",
        "operationId" : "updateCallbackSecret",
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "The newly generated callback secret.",
            "schema" : {
              "$ref" : "#/definitions/callbackSecret"
            }
          }
        }
      }
    },
    "/domain/admin/user" : {
      "post" : {
        "tags" : [ "domain" ],
        "summary" : "Create a new domain user.",
        "description" : "Use this operation to create a new domain user.<br>\nThe properties `id`, `created`, `lastModified`, `info` and `status` are read-only and so must not be provided: they are managed by the platform and added to the returned user.\n",
        "operationId" : "createDomainUser",
        "parameters" : [ {
          "in" : "body",
          "name" : "user",
          "description" : "User object to create (password must be provided).",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/user"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The created user.",
            "schema" : {
              "$ref" : "#/definitions/user"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        }
      }
    },
    "/domain/admin/user/{userId}" : {
      "get" : {
        "tags" : [ "domain" ],
        "summary" : "Get a domain user by its identifier.",
        "description" : "Use this operation to retrieve a domain user by its identifier.",
        "operationId" : "getDomainUser",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "Identifier of the domain user to retrieve.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The user.",
            "schema" : {
              "$ref" : "#/definitions/user"
            }
          },
          "404" : {
            "description" : "No user matching the given identifier."
          }
        }
      },
      "put" : {
        "tags" : [ "domain" ],
        "summary" : "Update a domain user.",
        "description" : "Use this operation to update a domain user.",
        "operationId" : "updateDomainUser",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "Identifier of the domain user to update.",
          "required" : true,
          "type" : "string"
        }, {
          "in" : "body",
          "name" : "user",
          "description" : "User object to update.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/user"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "The updated user.",
            "schema" : {
              "$ref" : "#/definitions/user"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          },
          "404" : {
            "description" : "No user matching the given identifier."
          }
        }
      },
      "delete" : {
        "tags" : [ "domain" ],
        "summary" : "Delete a domain user.",
        "description" : "Use this operation to delete a domain user.",
        "operationId" : "deleteDomainUser",
        "parameters" : [ {
          "name" : "userId",
          "in" : "path",
          "description" : "Identifier of the domain user to delete.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "The user is deleted."
          },
          "404" : {
            "description" : "No user matching the given identifier."
          }
        }
      }
    },
    "/domain/admin/users" : {
      "get" : {
        "tags" : [ "domain" ],
        "summary" : "Search for domain users.",
        "description" : "Use this operation to list all domain users or search for domain users given their email.<br>\nPaging and sorting is supported.\n",
        "operationId" : "searchDomainUsers",
        "parameters" : [ {
          "name" : "page",
          "in" : "query",
          "description" : "Index of the page to retrieve (from 0).",
          "required" : false,
          "type" : "integer",
          "default" : 0
        }, {
          "name" : "size",
          "in" : "query",
          "description" : "Number of users per page.",
          "required" : false,
          "type" : "integer",
          "default" : 20
        }, {
          "name" : "direction",
          "in" : "query",
          "description" : "Sorting direction: ASC for ascending DESC for descending.\n",
          "required" : false,
          "type" : "string",
          "default" : "ASC",
          "enum" : [ "ASC", "DESC" ]
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sorting property: possible values are `email`, `created`, `roles`, `info.firstName`, `info.lastName`, `status`.\n",
          "required" : false,
          "type" : "string",
          "default" : "created",
          "enum" : [ "email", "created", "roles", "info.firstName", "info.lastName", "status" ]
        }, {
          "name" : "email",
          "in" : "query",
          "description" : "email to search for: a sub-string of the email.\n",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "An array of all users matching all search criteria, plus additional paging and sorting information.",
            "schema" : {
              "$ref" : "#/definitions/users"
            }
          },
          "400" : {
            "description" : "Invalid request. More details are returned in the response body as a JSON object."
          }
        }
      }
    }
  },
  "securityDefinitions" : {
    "BasicAuth" : {
      "description" : "Basic authentication over `HTTPS`.<br>\nYou must provide `Base64(\"{email}:{password}\")` in the `Basic` scheme of the `Authorization` header.\n",
      "type" : "basic"
    },
    "JWTAuth" : {
      "description" : "JWT authentication over `HTTPS`.<br>\nYou must provide a JWT token value in the `Bearer` scheme of the `Authorization` header.\n",
      "type" : "apiKey",
      "name" : "Authorization",
      "in" : "header"
    }
  },
  "definitions" : {
    "receipt" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "description" : "Type of proof receipt."
        },
        "targetHash" : {
          "type" : "string",
          "description" : "SHA256 hash of the proven data or signature."
        },
        "merkleRoot" : {
          "type" : "string",
          "description" : "Root of the Merkle tree."
        },
        "proof" : {
          "type" : "array",
          "description" : "Merkle proof (path from `targetHash` to `merkleRoot` in the Merkle tree).",
          "items" : {
            "$ref" : "#/definitions/receipt_proof_node"
          }
        },
        "anchors" : {
          "type" : "array",
          "description" : "List of sources where the root of the Merkle proof is anchored.",
          "items" : {
            "$ref" : "#/definitions/receipt_anchors_node"
          }
        },
        "signature" : {
          "$ref" : "#/definitions/receipt_signature"
        }
      },
      "description" : "A Chainpoint 2.x proof receipt"
    },
    "receipt_proof_node" : {
      "type" : "object",
      "properties" : {
        "left" : {
          "type" : "string"
        },
        "right" : {
          "type" : "string"
        }
      }
    },
    "receipt_anchors_node" : {
      "type" : "object",
      "properties" : {
        "type" : {
          "type" : "string",
          "default" : "BTCOpReturn"
        },
        "sourceId" : {
          "type" : "string"
        }
      }
    },
    "receipt_signature" : {
      "type" : "object",
      "properties" : {
        "signedHash" : {
          "type" : "string",
          "description" : "SHA256 hash (ie. the fingerprint) of the signed file."
        },
        "signedIdentity" : {
          "type" : "string",
          "description" : "X500 Distinguished Name representing the signed identity."
        },
        "signedIssuerDomain" : {
          "type" : "string",
          "description" : "Domain name of the identity issuer (ie. of the organization who verified the identity)."
        },
        "pubKey" : {
          "type" : "string",
          "description" : "Public key of the signer.<br>\n**Currently only Bitcoin addresses are supported.**\n"
        },
        "signature" : {
          "type" : "string",
          "description" : "Signature of the `signedHash` property using the public key `pubKey`, or, if any of `signedIdentity` or `signedIssuerDomain` is provided,\nsignature of SHA256(`hashToSign` + `signedIdentity` + `signedIssuerDomain`) using the public key `pubKey`.\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook to use to verify the signer's identity."
        }
      },
      "description" : "For proof of signature receipts only. The anchored signature."
    },
    "otsReceipt" : {
      "type" : "string",
      "format" : "binary"
    },
    "pdfFile" : {
      "type" : "string",
      "format" : "binary"
    },
    "signatureRequest" : {
      "type" : "object",
      "required" : [ "hashToSign", "name" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Signature request identifier. It is allocated by the platform, and so must not be provided at creation time.",
          "readOnly" : true
        },
        "created" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of creation (in milliseconds since Unix epoch).",
          "readOnly" : true
        },
        "lastModified" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of last modification (in milliseconds since Unix epoch).",
          "readOnly" : true
        },
        "name" : {
          "type" : "string",
          "description" : "Name of the signature request (doesn't need to be unique)."
        },
        "state" : {
          "$ref" : "#/definitions/signatureRequestState"
        },
        "callbackURL" : {
          "type" : "string",
          "description" : "Web hook to be called by the platform whenever the signature request state changes:<br>\nthe platform does a POST request on this URL with the signature request as a JSON object in the request body.<br>\nVerifying the authenticity of the callback can be done by checking the HMAC-SHA1 signature of the request body provided by Woleet in the `x-woleet-signature` header.<br>\nPlease refer to the <a target=\"_blank\" href=\"https://doc.woleet.io/reference#using-callbacks\">documentation</a> for more details.\n"
        },
        "vars" : {
          "type" : "object",
          "example" : "{\"requesterName\":\"ACME Corp.\"}",
          "description" : "A set of variables (key/value pairs) that can be used to customize the signature request workflow.<br>\nValues must be of type null, boolean, string or number: nested JSON objects are not allowed.<br>\nIn particular, these variables can be used to customize the various email sent and disable some of these emails.<br>\nPlease refer to the <a target=\"_blank\" href=\"https://doc.woleet.io/reference#customize-signature-workflow\">documentation</a> for more details.<br>\n**This property is only available to the owner and the signers of the signature request.**\n",
          "properties" : { }
        },
        "lang" : {
          "type" : "string",
          "example" : "fr",
          "description" : "The preferred language (provided as an ISO 639-1 string) to use when emailing the signers."
        },
        "public" : {
          "type" : "boolean",
          "description" : "`true` (or unset) if the signature request is public (ie. discoverable by its `hashToSign`).<br>\n`false` if it must be private (ie. not discoverable).<br>\n**If this property is not set, the signature request is public by default.**<br>\n**Signature anchors created in the scope of a signature request inherit from its `public` property.**\n"
        },
        "hashToSign" : {
          "type" : "string",
          "description" : "SHA256 hash (ie. the fingerprint) of the original file to sign.<br>\nThe value must be provided as an hexadecimal lowercase string.\n"
        },
        "activation" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of activation of the signature request (in milliseconds since Unix epoch).<br>\nWhen not set or null, no activation date is applied.\n"
        },
        "deadline" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Deadline of the signature request (in milliseconds since Unix epoch).<br>\nWhen not set or null, no deadline is applied.<br>\nIf set, signatures registered after the deadline are refused.\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook to use to verify the signers' identity.<br>\nIf set, it is used to verify the identity of the signers at signature registration time.\n"
        },
        "fileName" : {
          "type" : "string",
          "description" : "Name of the file to sign.<br>\nIf set, the signature application can use it to give an indication about the file to the signers.\n"
        },
        "fileURL" : {
          "type" : "string",
          "description" : "Public URL of the original file to sign.<br>\nIf set, the signature application can use it to download and present the file to the signers.\n"
        },
        "maxSignatures" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Maximum number of signatures to accept for this signature request.<br>\nWhen not set or null, no maximum is applied.<br>\nThis property and the `authorizedSignees` property are mutually exclusive.<br>\n**This property is only available to the owner of the signature request.**\n"
        },
        "authorizedSignees" : {
          "type" : "array",
          "description" : "List of all signers authorized to register their signature (no duplicate is authorized).<br>\nWhen not set or null, anybody can sign the signature request.<br>\nIf set, signers not being part of this list are not allowed to register their signature.<br>\nThis property and the `maxSignatures` property are mutually exclusive.\n",
          "items" : {
            "$ref" : "#/definitions/authorizedSignee"
          }
        },
        "watchers" : {
          "type" : "array",
          "description" : "List of all watchers to notify by email about the progress of the signature request.<br>\nThe set of events being notified are:<br>\n- the signature request is activated<br>\n- a signer signs the signature request<br>\n- the signature request is canceled<br>\n- the signature request is closed or completed and the signature attestation is ready\n**This property is only available to the owner of the signature request.**\n",
          "items" : {
            "$ref" : "#/definitions/watcher"
          }
        },
        "ordered" : {
          "type" : "boolean",
          "description" : "`true` if the signers must sign in their order of appearance in the `authorizedSignees` list.<br>\nIn this mode, each signer is notified only when the previous signer completes his signature.<br>\n**Only stateful signature request can be ordered.**\n"
        },
        "anchors" : {
          "type" : "array",
          "description" : "List of signature anchors created in the scope of this signature request<br>\nA signature anchor is created each time a new signature is registered.\n",
          "readOnly" : true,
          "items" : {
            "$ref" : "#/definitions/anchor"
          }
        },
        "auditTrailData" : {
          "type" : "string",
          "description" : "Audit trail data.<br>\nWhen the signature request is COMPLETED (by the platform) or CLOSED (by the requester) its audit trail\n(ie. the list of events recorded by the platform during the signature request workflow) is serialized to a JSON array\nof objects and Base64 encoded. This Base64 data is signed by the platform and returned in this property.\n",
          "readOnly" : true
        },
        "auditTrailAnchorId" : {
          "type" : "string",
          "description" : "Identifier of the signature anchor created by the platform to sign the audit trail data.<br>\nThis property is set only once the audit trail is generated and can be used to retrieve its proof receipt.\n",
          "readOnly" : true
        },
        "attestationAnchorId" : {
          "type" : "string",
          "description" : "Identifier of the signature anchor created by the platform to sign the Signature Attestation document.<br>\nThis property is set only once the signature attestation is generated and can be used to retrieve its proof receipt.\n",
          "readOnly" : true
        },
        "testMode" : {
          "type" : "boolean",
          "description" : "**WARNING: Do not use (test purpose only).**\n"
        }
      }
    },
    "signatureRequestState" : {
      "type" : "string",
      "description" : "State of the signature request.<br>\nIf not set, the signature request is stateless and can be updated at any time (legacy mode).<br>\nIf set to 'DRAFT' at creation time, the signature request is stateful and its state can be transitioned using the dedicated endpoint.<br>\nAvailable states:<br>\n- `DRAFT`: the signature request is being edited (only `DRAFT` signature requests can be updated)<br>\n- `PENDING`: the signature request is awaiting for its activation date<br>\n- `IN_PROGRESS`: the activation date has been reached, the invitation emails have been sent to the signers (if applicable) and signatures are being collected<br>\n- `COMPLETED`: all signatures have been collected<br>\n- `CLOSED`: the signature request has been closed by the owner before all signatures could be collected<br>\n- `CANCELED`: the signature request has been canceled by the owner before all signatures could be collected<br>\n- `EXPIRED`: the deadline of the signature request has been reached before all signatures could be collected\n",
      "enum" : [ "DRAFT", "PENDING", "IN_PROGRESS", "COMPLETED", "CLOSED", "CANCELED", "EXPIRED" ]
    },
    "signatureRequests" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of signature requests matching the search criteria.",
          "items" : {
            "$ref" : "#/definitions/signatureRequest"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of requests in the retrieved page."
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of requests per page."
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0)."
        }
      }
    },
    "signatureRequestIds" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of identifiers of signature requests matching the search criteria.",
          "items" : {
            "type" : "string"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "totalPages" : {
          "type" : "integer",
          "description" : "Total number of pages available."
        },
        "totalElements" : {
          "type" : "integer",
          "description" : "Total number of signature requests matching the search criteria."
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of signature requests in the retrieved page."
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of signature requests per page."
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0)."
        }
      }
    },
    "authorizedSignee" : {
      "type" : "object",
      "properties" : {
        "email" : {
          "type" : "string",
          "example" : "john.doe@acme.com",
          "description" : "The email of the signer.<br>\nIf set, an email is sent by the platform to the signer, and `commonName` must also be set.<br>\nIf set, `pubKey` is not mandatory, to allow the signer to sign using any key.\n"
        },
        "vars" : {
          "type" : "object",
          "description" : "A set of variables (key/value pairs) that can be used to customize the signature request workflow for this signer.<br>\nValues must be of type null, boolean, string or number: nested JSON objects are not allowed.<br>\nVariables defined here overwrites the ones defined at signature request level when emailing the signer.<br>\n**This property is only available to the owner and the signers of the signature request.**\n",
          "properties" : { }
        },
        "lang" : {
          "type" : "string",
          "example" : "fr",
          "description" : "The preferred language (provided as an ISO 639-1 string) to use when emailing the signer.<br>\nIf set, this property overwrites the `lang` property defined at signature request level.\n"
        },
        "pubKey" : {
          "type" : "string",
          "description" : "The public key the signer must use to sign.<br>\n**Currently only Bitcoin addresses are supported.**<br>\nIf not set, the signer can sign using any key.\n"
        },
        "device" : {
          "type" : "string",
          "description" : "The type of device the signer should use to sign:<br>\n- SERVER: Woleet.ID Server or equivalent<br>\n- MOBILE: Woleet.ID Mobile or equivalent<br>\n- NANO: Ledger Nano S or equivalent<br>\nIf set, the signature application can use it to propose only the corresponding signature mode.\n",
          "enum" : [ "SERVER", "MOBILE", "NANO" ]
        },
        "countryCallingCode" : {
          "type" : "string",
          "example" : "33",
          "description" : "The country calling code of the signer (numbers only, no white space)."
        },
        "phone" : {
          "type" : "string",
          "example" : "612345678",
          "description" : "The phone of the signer (not including the country calling code, numbers only, no white spaces).<br>\nThis phone must be able to receive an OTP by SMS.\n"
        },
        "requiresOTP" : {
          "type" : "boolean",
          "description" : "`true` if the signer must provide an OTP to sign.<br>\nIf `true`, `phone` must be set, since the OTP is sent by SMS.\n"
        },
        "commonName" : {
          "type" : "string",
          "example" : "John Doe",
          "description" : "The full name of the signer."
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook to use to verify the signer's identity.<br>\nIf set, this property overwrites the `identityURL` property defined at signature request level.\n"
        },
        "feedbackSubject" : {
          "type" : "string",
          "description" : "Last feedback subject reported by the signer to the owner of the signature request.<br>\n**This property is only available to the owner of the signature request.**\n",
          "readOnly" : true
        },
        "feedbackMessage" : {
          "type" : "string",
          "description" : "Last feedback message reported by the signer to the owner of the signature request.<br>\n**This property is only available to the owner of the signature request.**\n",
          "readOnly" : true
        },
        "anchorId" : {
          "type" : "string",
          "description" : "If the signer has signed, identifier of the signature anchor created.",
          "readOnly" : true
        },
        "signedOn" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "If the signer has signed, date of signature (in milliseconds since Unix epoch).",
          "readOnly" : true
        },
        "auditTrailId" : {
          "type" : "string",
          "description" : "Identifier of the signer in the audit trail.",
          "readOnly" : true
        },
        "id" : {
          "type" : "string",
          "description" : "**WARNING: Do not use (test purpose only).**\n",
          "readOnly" : true
        },
        "OTP" : {
          "type" : "string",
          "description" : "**WARNING: Do not use (test purpose only).**\n",
          "readOnly" : true
        }
      }
    },
    "watcher" : {
      "type" : "object",
      "properties" : {
        "email" : {
          "type" : "string",
          "example" : "john.doe@acme.com",
          "description" : "The email of the watcher.\n"
        },
        "commonName" : {
          "type" : "string",
          "example" : "John Doe",
          "description" : "The full name of the watcher."
        },
        "vars" : {
          "type" : "object",
          "description" : "A set of variables (key/value pairs) that can be used to customize the signature request workflow for this watcher.<br>\nValues must be of type null, boolean, string or number: nested JSON objects are not allowed.<br>\nVariables defined here overwrites the ones defined at signature request level when emailing the watcher.\n",
          "properties" : { }
        },
        "lang" : {
          "type" : "string",
          "description" : "The preferred language (provided as an ISO 639-1 string) to use when emailing the watcher.<br>\nIf set, this property overwrites the `lang` property defined at signature request level.\n"
        }
      }
    },
    "signatureRequestSign" : {
      "type" : "object",
      "required" : [ "pubKey", "signature" ],
      "properties" : {
        "signature" : {
          "type" : "string",
          "description" : "Signature of the `hashToSign` property of the signature request using the public key `pubKey`, or, if any of `signedIdentity` or `signedIssuerDomain` is provided,\nsignature of SHA256(`hashToSign` + `signedIdentity` + `signedIssuerDomain`) using the public key `pubKey`.\n"
        },
        "pubKey" : {
          "type" : "string",
          "description" : "Public key used to sign."
        },
        "signedIdentity" : {
          "type" : "string",
          "description" : "X500 Distinguished Name representing the signed identity.<br>\nIf set, the CN (common name) and EMAILADDRESS (email address) attributes must match the common name and email address of the signer as set in the signature request.\n"
        },
        "signedIssuerDomain" : {
          "type" : "string",
          "description" : "Domain name of the identity issuer (ie. of the organization who verified the identity).<br>\nIf set, the domain name of the identity URL must be included in the `signedIssuerDomain` domain name.\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook to use to verify the signer's identity.<br>\nIf set, it is used in place of the `identityURL` property of the signer to create the signature anchor.\n"
        },
        "device" : {
          "type" : "string",
          "description" : "Type of device used to sign:<br>\n- SERVER: Woleet.ID Server or equivalent<br>\n- MOBILE: Woleet.ID Mobile or equivalent<br>\n- NANO: Ledger Nano S or equivalent\n",
          "enum" : [ "SERVER", "MOBILE", "NANO" ]
        },
        "signeeId" : {
          "type" : "string",
          "description" : "Secret identifier of the signer (provided by email)."
        },
        "OTP" : {
          "type" : "string",
          "description" : "OTP of the signer (only required if `requiresOTP` was set to `true` for ths signer).\n"
        }
      }
    },
    "signatureRequestDelegate" : {
      "type" : "object",
      "required" : [ "signeeId" ],
      "properties" : {
        "signeeId" : {
          "type" : "string",
          "description" : "Secret identifier of the signer (provided by email)."
        },
        "OTP" : {
          "type" : "string",
          "description" : "OTP of the signer (only required if `requiresOTP` was set to `true` for ths signer).\n"
        }
      }
    },
    "signatureRequestFeedback" : {
      "type" : "object",
      "required" : [ "message", "signeeId", "subject" ],
      "properties" : {
        "signeeId" : {
          "type" : "string",
          "description" : "Secret identifier of the signer (provided by email)."
        },
        "subject" : {
          "type" : "string",
          "description" : "Feedback subject to report to the owner of the signature request."
        },
        "message" : {
          "type" : "string",
          "description" : "Feedback message to report to the owner of the signature request."
        }
      }
    },
    "signatureRequestSignResult" : {
      "type" : "object",
      "properties" : {
        "anchorId" : {
          "type" : "string",
          "description" : "Identifier of the signature anchor created."
        }
      }
    },
    "anchor" : {
      "type" : "object",
      "required" : [ "name" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "Anchor identifier. It is allocated by the platform, and so must not be provided at creation time.",
          "readOnly" : true
        },
        "created" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of creation (in milliseconds since Unix epoch).",
          "readOnly" : true
        },
        "lastModified" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of last modification (in milliseconds since Unix epoch).",
          "readOnly" : true
        },
        "name" : {
          "type" : "string",
          "description" : "Name of the anchor (doesn't need to be unique)."
        },
        "hash" : {
          "type" : "string",
          "description" : "SHA256 hash (ie. the fingerprint) of the original data to anchor.<br>\nThe value must be provided as an hexadecimal lowercase string.<br>\n**This property must not be provided when creating a signature anchor: it is set at creation time to the SHA256 hash of the `signature` property provided (so the signature is what is actually anchored in this case).**\n"
        },
        "signedHash" : {
          "type" : "string",
          "description" : "SHA256 hash (ie. the fingerprint) of the original signed data.<br>\nThe value must be provided as an hexadecimal lowercase string.<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "signedIdentity" : {
          "type" : "string",
          "description" : "X500 Distinguished Name representing the signed identity.<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "signedIssuerDomain" : {
          "type" : "string",
          "description" : "Domain name of the identity issuer (ie. of the organization who verified the identity).<br>\nIf set, the domain name of the identity URL must be included in the `signedIssuerDomain` domain name.<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "pubKey" : {
          "type" : "string",
          "description" : "Public key of the signer.<br>\n**Currently only Bitcoin addresses are supported.**<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "signature" : {
          "type" : "string",
          "description" : "Signature of the `signedHash` property using the public key `pubKey`, or, if any of the `signedIdentity` or `signedIssuerDomain` properties are provided,\nsignature of SHA256(`hashToSign` + `signedIdentity` + `signedIssuerDomain`) using the public key `pubKey`.<br>\n**Only Bitcoin signatures are currently supported.**<br>\n**This property must not be provided when creating a data anchor.**\n"
        },
        "identityURL" : {
          "type" : "string",
          "description" : "Web hook of the identity server to use to verify the signer's identity.<br>\nThis URL allows to retrieve the identity associated to the public key `pubKey`.\nIt can also be used to verify that the identity server (itself identified by the TLS certificate of the URL) controls the key used to sign (ie. owns the private part of the key pair) by requesting it to sign some random data.<br>\nThis URL MUST use an HTTPS scheme with a valid and non expired TLS certificate.<br>\nThis URL MUST implement the following GET operation:<br>\nQuery parameters:<br>\n- `pubKey`: the public key to be verified - mandatory<br>\n- `leftData`: the left part of the data to be signed (generated randomly by the caller) - if set, the identity server MAY provide a `signature`<br>\nOutput:<br>\nA JSON object with:\n- `rightData`: the right part of the data signed (generated randomly by the identity server) - optional<br>\n- `signature`: the signature of the string `leftData` + `rightData` using the public key `pubKey` - optional<br>\n- `identity`: the X500 identity associated to the key claimed by the identity server - optional<br>\n- `key`: additional information about the key - optional<br>\nIf `identity` is not provided, `signature` and `rightData` MUST be provided: in such a case the identity of the signer can be extracted from the TLS certificate.\n"
        },
        "public" : {
          "type" : "boolean",
          "description" : "`true` (or unset) if the anchor is public (ie. discoverable by its `hash` or `signedHash`).<br>\n`false` if it must be private (ie. not discoverable).<br>\n**If this property is not set, the anchor is public by default.**\n"
        },
        "notifyByEmail" : {
          "type" : "boolean",
          "description" : "`true` if the proof receipt must be sent by email once available, or `false` (or unset) if not.\n"
        },
        "tags" : {
          "type" : "array",
          "description" : "Set of tags associated to the anchor. There is no restriction on tag names, except they cannot contain spaces.<br>\nTags are aimed at classifying and searching anchors.\n",
          "items" : {
            "type" : "string"
          }
        },
        "metadata" : {
          "type" : "object",
          "example" : "{\"title\":\"Ubik\",\"author\":\"Philip K. Dick\",\"read\":true,\"rank\":10.0}",
          "description" : "A set of variables (key/values pairs) to store with the anchor and giving additional information about the anchored data.<br>\nValues must be of type null, boolean, string or number: nested JSON objects are not allowed.\n",
          "properties" : { }
        },
        "callbackURL" : {
          "type" : "string",
          "description" : "Web hook to be called by the platform whenever the anchor status changes:<br>\nthe platform does a POST request on this URL with the anchor as a JSON object in the request body.<br>\nVerifying the authenticity of the callback can be done by checking the HMAC-SHA1 signature of the request body provided by Woleet in the `x-woleet-signature` header.<br>\nPlease refer to the <a target=\"_blank\" href=\"https://doc.woleet.io/reference#using-callbacks\">documentation</a> for more details.\n"
        },
        "status" : {
          "type" : "string",
          "description" : "Status of the anchor:<br>\n- WAIT: waiting to be processed by the platform (the proof receipt is not yet available for download)<br>\n- NEW: waiting to be sent to the blockchain (the proof receipt is not yet available for download)<br>\n- SENT: sent to the blockchain (the proof receipt can be downloaded)<br>\n- CONFIRMED: confirmed at least 6 times by the blockchain (the proof receipt can be verified)\n",
          "readOnly" : true,
          "enum" : [ "WAIT", "NEW", "SENT", "CONFIRMED" ]
        },
        "timestamp" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Proven timestamp of the data (for a data anchor) or of the signature (for a signature anchor).<br>\nThis is actually the time of the Bitcoin block into which the anchoring process occurred (in milliseconds since Unix epoch).<br>\nAny data whose SHA256 hash equals this anchor's hash is proven to exist at that time and has not been modified since.<br>\nThis property is set when the first confirmation of the Bitcoin block occurs. Once set, the associated proof receipt can be verified (without having to wait for 6 confirmations).\n",
          "readOnly" : true
        },
        "confirmations" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of confirmations of the Bitcoin block into which the anchoring process occurred.<br>\nThis property is set when the first confirmation of the Bitcoin block occurs, and removed once the block is confirmed at least 6 times.\n",
          "readOnly" : true
        },
        "txId" : {
          "type" : "string",
          "description" : "Identifier of the Bitcoin transaction where the anchoring occurred.",
          "readOnly" : true
        }
      }
    },
    "anchors" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of anchors matching the search criteria.",
          "items" : {
            "$ref" : "#/definitions/anchor"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of anchors in the retrieved page."
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of anchors per page."
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0)."
        }
      }
    },
    "anchorIds" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of identifiers of anchors matching the search criteria.",
          "items" : {
            "type" : "string"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "totalPages" : {
          "type" : "integer",
          "description" : "Total number of pages available."
        },
        "totalElements" : {
          "type" : "integer",
          "description" : "Total number of anchors matching the search criteria."
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of anchors in the retrieved page."
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of anchors per page."
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0)."
        }
      }
    },
    "receiptVerificationStatus" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "type" : "string",
          "description" : "Proof receipt verification status code:<br>\n- VERIFIED: success: the proof receipt is verified<br>\nThe receipt format is valid, the transaction is present in the Bitcoin blockchain and confirmed at least once,\nthe receipt contains a valid Merkle proof linking its `targetHash` property to the transaction's `OP_RETURN` field.<br>\nThe creation time and the number of confirmation of the block containing the transaction is returned\nin the `timestamp` and `confirmations` properties.<br>\nAny data whose SHA256 hash matches the proof receipt's `targetHash` is proven to exist at that time and has not been modified since.<br>\n- TX_NOT_CONFIRMED: warning: the transaction is not yet confirmed by the blockchain (ie. not yet included in a block)<br>\n- TX_NOT_FOUND: error: the receipt's `anchors` property does not include a valid Bitcoin transaction<br>\n- INVALID_PROOF: error: the receipt's `proof` property is not a valid Merkle proof<br>\n- TX_MISMATCH_RECEIPT: error: the receipt's `merkleRoot` property does not match the transaction's `OP_RETURN` field<br>\n- INVALID_SIGNATURE: error: the receipt's `signature` property is not a valid signature\n",
          "enum" : [ "VERIFIED", "TX_NOT_CONFIRMED", "INVALID_PROOF", "TX_NOT_FOUND", "TX_MISMATCH_RECEIPT", "INVALID_SIGNATURE" ]
        },
        "text" : {
          "type" : "string",
          "description" : "Proof receipt verification status text giving more insight about verification errors."
        },
        "timestamp" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Proven timestamp of the data (for a data anchor) or of the signature (for a signature anchor).<br>\nThis is actually the time of the Bitcoin block into which the anchoring process occurred (in milliseconds since Unix epoch).<br>\nAny data whose SHA256 hash equals this proof receipt's target hash property is proven to exist at that time and has not been modified since.\n"
        },
        "confirmations" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of confirmations of the Bitcoin block into which the anchoring process occurred."
        },
        "identityVerificationStatus" : {
          "$ref" : "#/definitions/identityVerificationStatus"
        }
      }
    },
    "identityVerificationStatus" : {
      "type" : "object",
      "properties" : {
        "code" : {
          "type" : "string",
          "description" : "Identity verification status code:<br>\n- VERIFIED: success: the key is controlled by the identity server,<br>\nand/or the key is associated to an identity on the identity server,<br>\nand/or the identity is included in the anchored signature,<br>\nand/or the signed identity matches the one claimed by the identity server,<br>\n- IDENTITY_MISMATCH: error: the identity included in the anchored signature mismatch the identity claimed by the identity server<br>\n- INVALID_SIGNATURE: error: the identity URL returned an invalid signature (ie. the identity server failed to prove that it owns the private part of key pair)<br>\n- HTTP_ERROR: error: the identity URL returned an HTTP error<br>\n- DEPRECATED_KEY: error: the key expired or was revoked before the signature timestamp.\n",
          "enum" : [ "VERIFIED", "HTTP_ERROR", "IDENTITY_MISMATCH", "INVALID_SIGNATURE", "DEPRECATED_KEY" ]
        },
        "text" : {
          "type" : "string",
          "description" : "Identity verification status text (gives more insights about the verification process)."
        },
        "certificates" : {
          "type" : "array",
          "description" : "Array of subjects and issuers of the certificates extracted from the identity URL's TLS certificate.",
          "items" : {
            "$ref" : "#/definitions/X509SubjectIssuer"
          }
        },
        "identity" : {
          "$ref" : "#/definitions/identity"
        },
        "signedIdentity" : {
          "$ref" : "#/definitions/identity"
        },
        "signedIssuerDomain" : {
          "type" : "string",
          "description" : "Domain name of the identity issuer (ie. of the organization who verified the identity)."
        },
        "key" : {
          "$ref" : "#/definitions/key"
        }
      }
    },
    "X509SubjectIssuer" : {
      "type" : "object",
      "properties" : {
        "subject" : {
          "$ref" : "#/definitions/X500Name"
        },
        "issuer" : {
          "$ref" : "#/definitions/X500Name"
        }
      }
    },
    "X500Name" : {
      "type" : "object",
      "properties" : {
        "C" : {
          "type" : "string",
          "description" : "Country code"
        },
        "ST" : {
          "type" : "string",
          "description" : "State or Province"
        },
        "L" : {
          "type" : "string",
          "description" : "Locality"
        },
        "O" : {
          "type" : "string",
          "description" : "Organization"
        },
        "OU" : {
          "type" : "string",
          "description" : "Organizational Unit"
        },
        "CN" : {
          "type" : "string",
          "description" : "Common Name"
        },
        "EMAILADDRESS" : {
          "type" : "string",
          "description" : "Email address"
        }
      },
      "description" : "X500 Distinguished Name."
    },
    "identity" : {
      "type" : "object",
      "required" : [ "commonName" ],
      "properties" : {
        "commonName" : {
          "type" : "string",
          "example" : "Jim Smith",
          "description" : "commonName (CN) (2.5.4.3)"
        },
        "organization" : {
          "type" : "string",
          "example" : "Woleet",
          "description" : "organizationName (O) (2.5.4.10)"
        },
        "organizationalUnit" : {
          "type" : "string",
          "example" : "Sales",
          "description" : "organizationalUnitName (OU) (2.5.4.11)"
        },
        "locality" : {
          "type" : "string",
          "example" : "Rennes",
          "description" : "localityName (L) (2.5.4.7)"
        },
        "country" : {
          "type" : "string",
          "example" : "FR",
          "description" : "countryName (C) (2.5.4.6)"
        }
      },
      "description" : "Signer's identity provided as a set of X.500 attributes (see https://www.ietf.org/rfc/rfc4519.txt)."
    },
    "key" : {
      "type" : "object",
      "properties" : {
        "name" : {
          "type" : "string",
          "example" : "Jim Smith's key",
          "description" : "Key name."
        },
        "pubKey" : {
          "type" : "string",
          "example" : "1GChJMuyxvq28F3Uksqf5v7QkxQ4WLQdBh",
          "description" : "Public key (bitcoin address when using BIP39 keys)."
        },
        "status" : {
          "type" : "string",
          "example" : "valid",
          "description" : "Key status:<br>\n`valid`: the key is valid and can be used to sign<br>\n`expired`: the key expired at `expiration`<br>\n`revoked`: the key was revoked at `revokedAt`\n",
          "enum" : [ "valid", "expired", "revoked" ]
        },
        "expiration" : {
          "type" : "integer",
          "format" : "int64",
          "example" : 1569542400000,
          "description" : "Key expiration date (Unix ms timestamp).\n<br>Note that this property is not returned if the key has no expiration date.\n"
        },
        "revokedAt" : {
          "type" : "integer",
          "format" : "int64",
          "example" : 1569542400000,
          "description" : "Key revocation date (Unix ms timestamp).\n<br>Note that this property is not returned if the key is not yet revoked.\n"
        }
      },
      "description" : "Key information."
    },
    "token" : {
      "type" : "object",
      "properties" : {
        "token" : {
          "type" : "string",
          "description" : "The JWT token value to provide in the `Bearer` scheme of the `Authorization` header."
        }
      }
    },
    "credits" : {
      "type" : "object",
      "properties" : {
        "credits" : {
          "type" : "integer",
          "description" : "The remaining number of anchoring credits of the authenticated user's account."
        },
        "signCredits" : {
          "type" : "integer",
          "description" : "The remaining number of signature credits of the authenticated user's account."
        }
      }
    },
    "info" : {
      "type" : "object",
      "properties" : {
        "firstName" : {
          "type" : "string",
          "description" : "User's first name."
        },
        "lastName" : {
          "type" : "string",
          "description" : "User's last name."
        },
        "company" : {
          "type" : "string",
          "description" : "User's company."
        },
        "country" : {
          "type" : "string",
          "description" : "User's country."
        }
      }
    },
    "user" : {
      "type" : "object",
      "required" : [ "email", "info", "password", "roles", "status" ],
      "properties" : {
        "id" : {
          "type" : "string",
          "description" : "User identifier. It is allocated by the platform, and so must not be provided at creation time.",
          "readOnly" : true
        },
        "created" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of creation (in milliseconds since Unix epoch).",
          "readOnly" : true
        },
        "lastModified" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Date of last modification (in milliseconds since Unix epoch).",
          "readOnly" : true
        },
        "email" : {
          "type" : "string",
          "description" : "Email of the user."
        },
        "password" : {
          "type" : "string",
          "description" : "Password of the user (it must be provided at creation time)."
        },
        "roles" : {
          "type" : "array",
          "description" : "Array of user roles.",
          "items" : {
            "type" : "string",
            "description" : "User role:<br>\n- ROLE_USER: regular user<br>\n- ROLE_DOMAIN_ADMIN: domain administrator.\n",
            "enum" : [ "ROLE_USER", "ROLE_DOMAIN_ADMIN" ],
            "default" : "ROLE_USER"
          }
        },
        "info" : {
          "$ref" : "#/definitions/info"
        },
        "status" : {
          "type" : "string",
          "description" : "The status of the user:<br>\n- PENDING: the user email need to be validated<br>\n- APPROVED: the user can loging<br>\n- DISABLED: the user cannot login\n",
          "enum" : [ "PENDING", "APPROVED", "DISABLED" ],
          "default" : "PENDING"
        }
      }
    },
    "users" : {
      "type" : "object",
      "properties" : {
        "content" : {
          "type" : "array",
          "description" : "Array of users matching the search criteria.",
          "items" : {
            "$ref" : "#/definitions/user"
          }
        },
        "first" : {
          "type" : "boolean",
          "description" : "`true` if this is the first page.\n"
        },
        "last" : {
          "type" : "boolean",
          "description" : "`true` if this is the last page.\n"
        },
        "numberOfElements" : {
          "type" : "integer",
          "description" : "Number of users in the retrieved page."
        },
        "size" : {
          "type" : "integer",
          "description" : "Number of users per page."
        },
        "number" : {
          "type" : "integer",
          "description" : "Index of the retrieved page (from 0)."
        }
      }
    },
    "callbackSecret" : {
      "type" : "object",
      "properties" : {
        "secret" : {
          "type" : "string",
          "description" : "The secret used to sign the callback."
        }
      }
    },
    "tokens" : {
      "type" : "object",
      "properties" : {
        "tokens" : {
          "type" : "array",
          "items" : {
            "type" : "string"
          }
        }
      }
    }
  },
  "x-samples-languages" : [ "curl", "javascript", "node", "java", "python", "php" ]
}